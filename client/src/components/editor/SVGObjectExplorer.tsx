
import React, { useState, useMemo, useEffect, useRef, useCallback } from "react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable";
import { 
  ChevronRight, 
  ChevronDown,
  FileImage,
  Layers,
  Search,
  Box,
  Palette,
  Move,
  X,
  Copy,
  Check,
  GitBranch,
  Tag,
  Info,
  AlertCircle,
  ChevronsDownUp,
  ChevronsUpDown,
  Filter,
  Pencil,
  Sparkles,
  Wand2,
  CheckCircle2,
  Ungroup,
  Focus,
  CornerUpLeft,
  ZoomIn,
  Eye,
  Figma,
  Film
} from "lucide-react";
import { cn } from "@/lib/utils";
import { SelectionProvider, useSelection, SelectionLineage } from "@/contexts/SelectionContext";

interface NameSuggestion {
  name: string;
  reason: string;
  confidence: 'high' | 'medium' | 'low';
  source: 'animate' | 'hierarchy' | 'type' | 'visual' | 'sibling';
}

type FilterMode = 'all' | 'symbols' | 'instances';

interface SVGGradient {
  id: string;
  type: 'linear' | 'radial';
  stops: Array<{ offset: string; color: string }>;
  x1?: string;
  y1?: string;
  x2?: string;
  y2?: string;
}

type NameSource = 'data-name' | 'aria-label' | 'id' | 'title' | 'class' | 'auto-generated';

interface SymbolDefinition {
  id: string;
  name: string;
  type: 'symbol' | 'g' | 'clipPath' | 'mask';
  element: Element;
}

interface AnimateIdInfo {
  isAnimateFormat: boolean;
  symbolPath: string[];
  instanceName: string;
  parentSymbol?: string;
  layerInfo?: string;
  memberIndex?: number;
  fillOrStroke?: 'FILL' | 'STROKE';
  cleanDisplayName: string;
}

interface SVGObject {
  id: string;
  rawId: string;
  name: string;
  displayName: string;
  nameSource: NameSource;
  isAutoGenerated: boolean;
  type: 'group' | 'path' | 'rect' | 'circle' | 'ellipse' | 'polygon' | 'text' | 'use';
  bounds?: { x: number; y: number; width: number; height: number };
  fill?: string;
  gradientId?: string;
  transform?: string;
  pathData?: string;
  children?: SVGObject[];
  originalMarkup?: string;
  parentId?: string;
  parentName?: string;
  parentType?: string;
  className?: string;
  dataName?: string;
  ariaLabel?: string;
  instanceOf?: string;
  symbolId?: string;
  isSymbolInstance?: boolean;
  animateInfo?: AnimateIdInfo;
  symbolPath?: string[];
}

export type ImportSourceType = 'figma' | 'illustrator' | 'animate';

interface SVGObjectExplorerProps {
  svgContent: string;
  sourceType?: ImportSourceType;
  onClose?: () => void;
  onImport?: (objects: SVGObject[], gradients: SVGGradient[]) => void;
}

function buildLineage(obj: SVGObject, objectMap: Map<string, SVGObject>, getDisplayNameFn?: (o: SVGObject) => string): SelectionLineage[] {
  const lineage: SelectionLineage[] = [];
  let current = obj;
  while (current.parentId && objectMap.has(current.parentId)) {
    const parent = objectMap.get(current.parentId)!;
    lineage.unshift({
      id: parent.id,
      displayName: getDisplayNameFn ? getDisplayNameFn(parent) : parent.displayName,
      type: parent.type
    });
    current = parent;
  }
  return lineage;
}

function buildLineageWithSelf(obj: SVGObject, objectMap: Map<string, SVGObject>, getDisplayNameFn?: (o: SVGObject) => string): SelectionLineage[] {
  const lineage = buildLineage(obj, objectMap, getDisplayNameFn);
  lineage.push({
    id: obj.id,
    displayName: getDisplayNameFn ? getDisplayNameFn(obj) : obj.displayName,
    type: obj.type
  });
  return lineage;
}

export function SVGObjectExplorer({ svgContent, sourceType = 'animate', onClose, onImport }: SVGObjectExplorerProps) {
  return (
    <SelectionProvider>
      <SVGObjectExplorerInner svgContent={svgContent} sourceType={sourceType} onClose={onClose} onImport={onImport} />
    </SelectionProvider>
  );
}

function SVGObjectExplorerInner({ svgContent, sourceType = 'animate', onClose, onImport }: SVGObjectExplorerProps) {
  const selection = useSelection();
  const [expandedIds, setExpandedIds] = useState<Set<string>>(new Set());
  const [searchTerm, setSearchTerm] = useState("");
  const [filterMode, setFilterMode] = useState<FilterMode>('all');
  const [renamedObjects, setRenamedObjects] = useState<Map<string, string>>(new Map());
  const [suggestions, setSuggestions] = useState<Map<string, NameSuggestion[]>>(new Map());
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [showBulkReview, setShowBulkReview] = useState(false);
  const [ungroupedIds, setUngroupedIds] = useState<Set<string>>(new Set());

  const { objects, gradients, viewBox, defsMarkup, objectMap, symbolRegistry, detectedSource } = useMemo(() => {
    return parseSVG(svgContent, sourceType);
  }, [svgContent, sourceType]);
  
  const handleUngroup = useCallback((groupId: string, groupName: string) => {
    const group = objectMap.get(groupId);
    if (!group || !group.children || group.children.length === 0) return;
    
    setUngroupedIds(prev => new Set(prev).add(groupId));
    
    if (group.children.length === 1) {
      const child = group.children[0];
      if (!renamedObjects.has(child.id)) {
        setRenamedObjects(prev => new Map(prev).set(child.id, groupName));
      }
    }
  }, [objectMap, renamedObjects]);
  
  const findGroupedInstances = useCallback((): SVGObject[] => {
    const groupedInstances: SVGObject[] = [];
    
    function traverse(objs: SVGObject[], parentIsGroup: boolean) {
      for (const obj of objs) {
        if ((obj.isSymbolInstance || obj.type === 'use') && parentIsGroup) {
          groupedInstances.push(obj);
        }
        if (obj.children) {
          traverse(obj.children, obj.type === 'group');
        }
      }
    }
    
    traverse(objects, false);
    return groupedInstances;
  }, [objects]);
  
  const selectGroupedInstances = useCallback(() => {
    const groupedInstances = findGroupedInstances();
    const parentIds = new Set<string>();
    
    groupedInstances.forEach(instance => {
      if (instance.parentId) {
        parentIds.add(instance.parentId);
        let current = objectMap.get(instance.parentId);
        while (current?.parentId) {
          parentIds.add(current.parentId);
          current = objectMap.get(current.parentId);
        }
      }
    });
    
    setExpandedIds(prev => new Set([...Array.from(prev), ...Array.from(parentIds)]));
    selection.replaceSelection(groupedInstances.map(obj => obj.id));
  }, [findGroupedInstances, objectMap, selection]);
  
  const getParentGroups = useCallback((objIds: Set<string>): Map<string, { group: SVGObject, children: SVGObject[] }> => {
    const parentGroups = new Map<string, { group: SVGObject, children: SVGObject[] }>();
    
    objIds.forEach(objId => {
      const obj = objectMap.get(objId);
      if (!obj || !obj.parentId) return;
      
      const parent = objectMap.get(obj.parentId);
      if (!parent || parent.type !== 'group') return;
      
      if (!parentGroups.has(parent.id)) {
        parentGroups.set(parent.id, { group: parent, children: [] });
      }
      parentGroups.get(parent.id)!.children.push(obj);
    });
    
    return parentGroups;
  }, [objectMap]);
  
  const ungroupAllSelected = useCallback(() => {
    const parentGroups = getParentGroups(selection.state.selectedIds);
    
    const newUngrouped = new Set(ungroupedIds);
    const newRenamed = new Map(renamedObjects);
    
    parentGroups.forEach(({ group, children }, groupId) => {
      newUngrouped.add(groupId);
      
      const groupName = renamedObjects.get(groupId) || group.displayName;
      
      if (children.length === 1) {
        const child = children[0];
        if (!newRenamed.has(child.id)) {
          newRenamed.set(child.id, groupName);
        }
      }
    });
    
    setUngroupedIds(newUngrouped);
    setRenamedObjects(newRenamed);
    selection.clearSelection();
  }, [selection, getParentGroups, ungroupedIds, renamedObjects]);
  
  const groupedInstancesCount = useMemo(() => {
    return findGroupedInstances().length;
  }, [findGroupedInstances]);
  
  const selectedGroupsCount = useMemo(() => {
    return getParentGroups(selection.state.selectedIds).size;
  }, [selection.state.selectedIds, getParentGroups]);
  
  const handleSelectObject = useCallback((obj: SVGObject, event?: React.MouseEvent) => {
    const lineage = buildLineage(obj, objectMap, getDisplayName);
    
    const wasDoubleClick = selection.isDoubleClick(obj.id);
    selection.recordClick(obj.id);
    
    if (wasDoubleClick && obj.type === 'group' && obj.children && obj.children.length > 0) {
      const isolationLineage = buildLineageWithSelf(obj, objectMap, getDisplayName);
      selection.enterIsolation(obj.id, getDisplayName(obj), isolationLineage);
      return;
    }
    
    if (event?.shiftKey || event?.metaKey || event?.ctrlKey) {
      selection.toggleSelect(obj.id);
    } else {
      selection.selectOne(obj.id, lineage);
    }
  }, [objectMap, selection, getDisplayName]);
  
  const handleAnalyzeNames = useCallback(() => {
    setIsAnalyzing(true);
    setTimeout(() => {
      const newSuggestions = generateAllSuggestions(objects, objectMap);
      setSuggestions(newSuggestions);
      setIsAnalyzing(false);
      if (newSuggestions.size > 0) {
        setShowBulkReview(true);
      }
    }, 100);
  }, [objects, objectMap]);

  const applySuggestion = useCallback((objectId: string, suggestedName: string) => {
    setRenamedObjects(prev => new Map(prev).set(objectId, suggestedName));
  }, []);

  const applyAllSuggestions = useCallback(() => {
    const newRenamed = new Map(renamedObjects);
    suggestions.forEach((suggestionList, objectId) => {
      if (suggestionList.length > 0 && !newRenamed.has(objectId)) {
        newRenamed.set(objectId, suggestionList[0].name);
      }
    });
    setRenamedObjects(newRenamed);
    setShowBulkReview(false);
  }, [suggestions, renamedObjects]);

  const filteredObjects = useMemo(() => {
    let result = objects;
    
    if (filterMode === 'symbols') {
      result = filterByType(result, (obj) => obj.type === 'group' && (obj.children?.length ?? 0) > 0);
    } else if (filterMode === 'instances') {
      result = filterByType(result, (obj) => obj.isSymbolInstance || obj.type === 'use');
    }
    
    if (searchTerm) {
      const lowerSearch = searchTerm.toLowerCase();
      result = filterObjects(result, lowerSearch);
    }
    
    return result;
  }, [objects, searchTerm, filterMode]);

  const searchResultCount = useMemo(() => {
    if (!searchTerm) return 0;
    return countObjects(filteredObjects);
  }, [filteredObjects, searchTerm]);

  const toggleExpanded = (id: string) => {
    setExpandedIds(prev => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  };

  const collapseAll = useCallback(() => {
    setExpandedIds(new Set());
  }, []);

  const selectedObject = useMemo(() => {
    const focusedId = selection.state.focusedObjectId;
    return focusedId ? objectMap.get(focusedId) || null : null;
  }, [selection.state.focusedObjectId, objectMap]);

  const expandToSelection = useCallback(() => {
    if (!selectedObject) return;
    const lineage = getLineageIds(selectedObject, objectMap);
    setExpandedIds(prev => new Set([...Array.from(prev), ...lineage]));
  }, [selectedObject, objectMap]);

  const handleRename = useCallback((objectId: string, newName: string) => {
    setRenamedObjects(prev => new Map(prev).set(objectId, newName));
  }, []);

  const getDisplayName = useCallback((obj: SVGObject) => {
    return renamedObjects.get(obj.id) || obj.displayName;
  }, [renamedObjects]);

  const handleImport = () => {
    onImport?.(objects, gradients);
  };

  const getLineage = (obj: SVGObject): SVGObject[] => {
    const lineage: SVGObject[] = [];
    let current = obj;
    while (current.parentId && objectMap.has(current.parentId)) {
      const parent = objectMap.get(current.parentId)!;
      lineage.unshift(parent);
      current = parent;
    }
    return lineage;
  };

  const totalObjects = countObjects(objects);
  const symbolCount = symbolRegistry.size;
  const instanceCount = countByType(objects, (obj) => obj.isSymbolInstance || obj.type === 'use');

  const isolatedGroup = useMemo(() => {
    if (!selection.state.isolatedGroupId) return null;
    return objectMap.get(selection.state.isolatedGroupId) || null;
  }, [selection.state.isolatedGroupId, objectMap]);

  const isolatedObjects = useMemo(() => {
    if (!isolatedGroup || !isolatedGroup.children) return filteredObjects;
    
    let result = isolatedGroup.children;
    
    if (filterMode === 'symbols') {
      result = filterByType(result, (obj) => obj.type === 'group' && (obj.children?.length ?? 0) > 0);
    } else if (filterMode === 'instances') {
      result = filterByType(result, (obj) => obj.isSymbolInstance || obj.type === 'use');
    }
    
    if (searchTerm) {
      const lowerSearch = searchTerm.toLowerCase();
      result = filterObjects(result, lowerSearch);
    }
    
    return result;
  }, [isolatedGroup, filteredObjects, filterMode, searchTerm]);

  const displayObjects = selection.state.isolatedGroupId ? isolatedObjects : filteredObjects;

  const handleEnterIsolation = useCallback(() => {
    if (!selectedObject) return;
    if (selectedObject.type === 'group' && selectedObject.children && selectedObject.children.length > 0) {
      const isolationLineage = buildLineageWithSelf(selectedObject, objectMap, getDisplayName);
      selection.enterIsolation(selectedObject.id, getDisplayName(selectedObject), isolationLineage);
    }
  }, [selectedObject, selection, getDisplayName, objectMap]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }

      if (e.key === 'Enter' && selectedObject) {
        e.preventDefault();
        handleEnterIsolation();
      }

      if (e.key === 'Escape') {
        e.preventDefault();
        if (selection.state.isolatedGroupId) {
          selection.exitIsolation();
        } else if (selection.state.selectedIds.size > 0) {
          selection.clearSelection();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedObject, selection, handleEnterIsolation]);

  return (
    <div className="flex flex-col h-full bg-background overflow-hidden">
      <div className="p-3 border-b space-y-2 shrink-0">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <h2 className="text-base font-semibold">
              {detectedSource === 'figma' ? 'Figma Import' : 
               detectedSource === 'illustrator' ? 'Illustrator Import' : 
               'Animate Import'}
            </h2>
            {detectedSource === 'figma' && (
              <Badge className="bg-[#0ACF83]/20 text-[#0ACF83] border-[#0ACF83]/30 text-[10px] flex items-center gap-1">
                <Figma className="w-3 h-3" />
                Figma
              </Badge>
            )}
            {detectedSource === 'illustrator' && (
              <Badge className="bg-[#FF9A00]/20 text-[#FF9A00] border-[#FF9A00]/30 text-[10px] flex items-center gap-1">
                <Palette className="w-3 h-3" />
                Illustrator
              </Badge>
            )}
            {detectedSource === 'animate' && (
              <Badge className="bg-purple-500/20 text-purple-700 dark:text-purple-300 border-purple-500/30 text-[10px] flex items-center gap-1">
                <Film className="w-3 h-3" />
                Animate
              </Badge>
            )}
            {detectedSource !== sourceType && (
              <Badge variant="outline" className="text-[10px] text-muted-foreground">
                Auto-detected
              </Badge>
            )}
          </div>
          {onClose && (
            <Button variant="ghost" size="icon" onClick={onClose} className="h-7 w-7">
              <X className="w-4 h-4" />
            </Button>
          )}
        </div>
        
        <div className="flex items-center gap-3 text-xs text-muted-foreground">
          <span className="flex items-center gap-1">
            <Layers className="w-3 h-3" />
            {totalObjects} objects
          </span>
          <span className="flex items-center gap-1">
            <Palette className="w-3 h-3" />
            {gradients.length} gradients
          </span>
          {symbolCount > 0 && (
            <span className="flex items-center gap-1">
              <Box className="w-3 h-3" />
              {symbolCount} symbols
            </span>
          )}
          {viewBox && (
            <span className="ml-auto">
              {viewBox.width} × {viewBox.height}px
            </span>
          )}
        </div>
        
        {selection.state.isolatedGroupId && isolatedGroup && (
          <div className="flex items-center gap-2 px-2 py-1.5 bg-[#0D99FF]/10 border border-[#0D99FF]/20 rounded-md">
            <Focus className="w-3.5 h-3.5 text-[#0D99FF]" />
            <div className="flex items-center gap-1 text-xs">
              <span className="text-muted-foreground">Isolating:</span>
              {selection.state.selectionLineage.map((item, idx) => (
                <React.Fragment key={item.id}>
                  {idx > 0 && <ChevronRight className="w-3 h-3 text-muted-foreground" />}
                  <button
                    className={cn(
                      "font-medium",
                      idx === selection.state.selectionLineage.length - 1 
                        ? "text-foreground cursor-default" 
                        : "text-[#0D99FF] hover:underline"
                    )}
                    onClick={() => {
                      if (idx === selection.state.selectionLineage.length - 1) return;
                      const targetLineage = selection.state.selectionLineage.slice(0, idx + 1);
                      const targetId = item.id;
                      selection.enterIsolation(targetId, item.displayName, targetLineage);
                    }}
                  >
                    {item.displayName}
                  </button>
                </React.Fragment>
              ))}
            </div>
            <div className="flex-1" />
            <Button
              variant="ghost"
              size="sm"
              className="h-5 px-1.5 text-[10px] gap-1 text-muted-foreground hover:text-foreground"
              onClick={() => selection.exitIsolation()}
              title="Exit isolation (Escape)"
            >
              <CornerUpLeft className="w-3 h-3" />
              Exit
            </Button>
            <Button
              variant="ghost"
              size="sm"
              className="h-5 px-1.5 text-[10px] text-muted-foreground hover:text-foreground"
              onClick={() => selection.exitToRoot()}
              title="Exit to root"
            >
              Exit All
            </Button>
          </div>
        )}
      </div>

      <div className="flex-1 min-h-0 overflow-hidden">
        <ResizablePanelGroup direction="horizontal" className="h-full">
          <ResizablePanel defaultSize={40} minSize={25} maxSize={60}>
            <div className="flex flex-col h-full">
              <div className="p-2 border-b space-y-2 shrink-0">
                <div className="flex items-center gap-1">
                  <div className="relative flex-1">
                    <Search className="absolute left-2 top-1/2 -translate-y-1/2 w-3 h-3 text-muted-foreground" />
                    <Input
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      placeholder="Search objects..."
                      className="h-7 text-xs pl-7"
                      data-testid="input-search-objects"
                    />
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-7 w-7 p-0"
                    onClick={collapseAll}
                    title="Collapse all"
                    data-testid="button-collapse-all"
                  >
                    <ChevronsDownUp className="w-3.5 h-3.5" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-7 w-7 p-0"
                    onClick={expandToSelection}
                    title="Expand to selection"
                    disabled={!selectedObject}
                    data-testid="button-expand-to-selection"
                  >
                    <ChevronsUpDown className="w-3.5 h-3.5" />
                  </Button>
                </div>
                
                <div className="flex items-center gap-1 flex-wrap">
                  <Button
                    variant={filterMode === 'all' ? 'secondary' : 'ghost'}
                    size="sm"
                    className="h-6 text-[10px] px-2"
                    onClick={() => setFilterMode('all')}
                  >
                    All
                  </Button>
                  <Button
                    variant={filterMode === 'symbols' ? 'secondary' : 'ghost'}
                    size="sm"
                    className="h-6 text-[10px] px-2"
                    onClick={() => setFilterMode('symbols')}
                  >
                    Symbols ({symbolCount})
                  </Button>
                  <Button
                    variant={filterMode === 'instances' ? 'secondary' : 'ghost'}
                    size="sm"
                    className="h-6 text-[10px] px-2"
                    onClick={() => setFilterMode('instances')}
                  >
                    Instances ({instanceCount})
                  </Button>
                  <div className="flex-1" />
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-6 text-[10px] px-2 gap-1"
                    onClick={handleAnalyzeNames}
                    disabled={isAnalyzing}
                    data-testid="button-analyze-names"
                  >
                    {isAnalyzing ? (
                      <>
                        <Sparkles className="w-3 h-3 animate-pulse" />
                        Analyzing...
                      </>
                    ) : (
                      <>
                        <Wand2 className="w-3 h-3" />
                        Suggest Names
                      </>
                    )}
                  </Button>
                  {searchTerm && (
                    <span className="text-[10px] text-muted-foreground">
                      {searchResultCount} found
                    </span>
                  )}
                </div>
                
                <div className="flex items-center gap-1 pt-1">
                  <Button
                    variant="outline"
                    size="sm"
                    className="h-6 text-[10px] px-2 gap-1"
                    onClick={selectGroupedInstances}
                    disabled={groupedInstancesCount === 0}
                    title="Select all instances that are inside groups"
                    data-testid="button-select-grouped-instances"
                  >
                    <GitBranch className="w-3 h-3" />
                    Select Grouped Instances ({groupedInstancesCount})
                  </Button>
                  
                  {selection.state.selectedIds.size > 0 && selectedGroupsCount > 0 && (
                    <Button
                      variant="default"
                      size="sm"
                      className="h-6 text-[10px] px-2 gap-1 bg-purple-600 hover:bg-purple-700"
                      onClick={ungroupAllSelected}
                      title="Ungroup all parent groups of selected items"
                      data-testid="button-ungroup-all-selected"
                    >
                      <Ungroup className="w-3 h-3" />
                      Ungroup All Selected ({selectedGroupsCount} groups)
                    </Button>
                  )}
                  
                  {selection.state.selectedIds.size > 0 && (
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-6 text-[10px] px-2"
                      onClick={() => selection.clearSelection()}
                      title="Clear selection"
                    >
                      Clear ({selection.state.selectedIds.size})
                    </Button>
                  )}
                </div>
              </div>
              
              <ScrollArea className="flex-1">
                <div className="p-2 space-y-0.5">
                  {displayObjects.length === 0 ? (
                    <div className="text-center text-muted-foreground text-xs py-8">
                      {selection.state.isolatedGroupId ? 'No objects in isolated group' : 'No objects found'}
                    </div>
                  ) : (
                    displayObjects.map((obj) => (
                      <ObjectTreeItem
                        key={obj.id}
                        object={obj}
                        isExpanded={expandedIds.has(obj.id)}
                        onToggle={() => toggleExpanded(obj.id)}
                        onSelect={(e) => handleSelectObject(obj, e)}
                        level={0}
                        expandedIds={expandedIds}
                        onToggleChild={toggleExpanded}
                        onSelectChild={handleSelectObject}
                        getDisplayName={getDisplayName}
                        onUngroup={handleUngroup}
                        ungroupedIds={ungroupedIds}
                        selection={selection}
                      />
                    ))
                  )}
                </div>
              </ScrollArea>
            </div>
          </ResizablePanel>
          
          <ResizableHandle withHandle />
          
          <ResizablePanel defaultSize={60} minSize={35}>
            <ResizablePanelGroup direction="vertical" className="h-full">
              <ResizablePanel defaultSize={50} minSize={25}>
                <SVGCanvasPreview
                  svgContent={svgContent}
                  objects={objects}
                  objectMap={objectMap}
                  selectedIds={selection.state.selectedIds}
                  isolatedGroupId={selection.state.isolatedGroupId}
                  viewBox={viewBox}
                  onSelectObject={handleSelectObject}
                  getDisplayName={getDisplayName}
                />
              </ResizablePanel>
              
              <ResizableHandle withHandle />
              
              <ResizablePanel defaultSize={50} minSize={20}>
                <ScrollArea className="h-full">
                  {selectedObject ? (
                    <ObjectDetails 
                      object={selectedObject} 
                      gradients={gradients} 
                      defsMarkup={defsMarkup}
                      rootViewBox={viewBox}
                      lineage={getLineage(selectedObject)}
                      displayName={getDisplayName(selectedObject)}
                      onRename={(newName) => handleRename(selectedObject.id, newName)}
                      suggestions={suggestions.get(selectedObject.id)}
                      onApplySuggestion={(name) => applySuggestion(selectedObject.id, name)}
                      onNavigateToParent={(obj) => {
                        const lineage = buildLineage(obj, objectMap, getDisplayName);
                        selection.selectOne(obj.id, lineage);
                        expandToSelection();
                      }}
                      getParentDisplayName={getDisplayName}
                    />
                  ) : (
                    <div className="flex flex-col items-center justify-center h-full text-center p-4">
                      <Box className="w-10 h-10 text-muted-foreground mb-3 opacity-50" />
                      <p className="text-sm text-muted-foreground">
                        Select an object to view details
                      </p>
                    </div>
                  )}
                </ScrollArea>
              </ResizablePanel>
            </ResizablePanelGroup>
          </ResizablePanel>
        </ResizablePanelGroup>
      </div>

      {showBulkReview && suggestions.size > 0 && (
        <div className="p-3 border-t bg-gradient-to-r from-purple-500/5 to-blue-500/5 shrink-0">
          <div className="flex items-center justify-between gap-4">
            <div className="flex items-center gap-2">
              <Sparkles className="w-4 h-4 text-purple-500" />
              <span className="text-sm font-medium">
                {suggestions.size} name suggestions available
              </span>
            </div>
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => setShowBulkReview(false)}
                className="text-xs"
              >
                Dismiss
              </Button>
              <Button
                size="sm"
                onClick={applyAllSuggestions}
                className="text-xs bg-gradient-to-r from-purple-500 to-blue-500 hover:from-purple-600 hover:to-blue-600"
                data-testid="button-apply-all-suggestions"
              >
                <Wand2 className="w-3 h-3 mr-1" />
                Apply All Suggestions
              </Button>
            </div>
          </div>
        </div>
      )}

      <div className="p-3 border-t flex items-center justify-between bg-muted/30 shrink-0">
        <div className="text-xs text-muted-foreground">
          Ready to import {totalObjects} objects
          {renamedObjects.size > 0 && (
            <span className="ml-2 text-primary">({renamedObjects.size} renamed)</span>
          )}
          {suggestions.size > 0 && !showBulkReview && (
            <Button
              variant="link"
              size="sm"
              className="ml-2 text-xs text-purple-600 dark:text-purple-400 p-0 h-auto"
              onClick={() => setShowBulkReview(true)}
            >
              ({suggestions.size} suggestions)
            </Button>
          )}
        </div>
        <div className="flex gap-2">
          {onClose && (
            <Button variant="outline" size="sm" onClick={onClose} data-testid="button-svg-cancel">
              Cancel
            </Button>
          )}
          <Button size="sm" onClick={handleImport} data-testid="button-svg-import">
            Import SVG
          </Button>
        </div>
      </div>
    </div>
  );
}

function getLineageIds(obj: SVGObject, objectMap: Map<string, SVGObject>): string[] {
  const ids: string[] = [];
  let current = obj;
  while (current.parentId && objectMap.has(current.parentId)) {
    ids.push(current.parentId);
    current = objectMap.get(current.parentId)!;
  }
  return ids;
}

function filterByType(objects: SVGObject[], predicate: (obj: SVGObject) => boolean): SVGObject[] {
  return objects.reduce<SVGObject[]>((acc, obj) => {
    if (predicate(obj)) {
      acc.push(obj);
    }
    if (obj.children) {
      const filteredChildren = filterByType(obj.children, predicate);
      if (filteredChildren.length > 0 && !predicate(obj)) {
        acc.push({ ...obj, children: filteredChildren });
      } else if (predicate(obj) && obj.children) {
        const idx = acc.findIndex(o => o.id === obj.id);
        if (idx >= 0) {
          acc[idx] = { ...acc[idx], children: filterByType(obj.children, predicate) };
        }
      }
    }
    return acc;
  }, []);
}

function countByType(objects: SVGObject[], predicate: (obj: SVGObject) => boolean): number {
  let count = 0;
  function traverse(objs: SVGObject[]) {
    for (const obj of objs) {
      if (predicate(obj)) count++;
      if (obj.children) traverse(obj.children);
    }
  }
  traverse(objects);
  return count;
}

function generateNameSuggestions(
  object: SVGObject, 
  objectMap: Map<string, SVGObject>,
  siblingObjects?: SVGObject[]
): NameSuggestion[] {
  const suggestions: NameSuggestion[] = [];
  
  const hasAnimateFormatName = object.animateInfo?.isAnimateFormat || 
    /_(FILL|STROKE|Layer|MEMBER)_?\d*$/i.test(object.rawId);
  
  if (!object.isAutoGenerated && object.nameSource !== 'auto-generated' && !hasAnimateFormatName) {
    return suggestions;
  }

  if (object.animateInfo?.isAnimateFormat && object.animateInfo.cleanDisplayName) {
    const cleanName = object.animateInfo.cleanDisplayName
      .replace(/\s+/g, '_')
      .replace(/[^a-zA-Z0-9_]/g, '');
    
    if (cleanName && cleanName !== object.displayName) {
      suggestions.push({
        name: cleanName,
        reason: `From Animate symbol: "${object.animateInfo.cleanDisplayName}"`,
        confidence: 'high',
        source: 'animate'
      });
    }
    
    if (object.animateInfo.symbolPath && object.animateInfo.symbolPath.length > 1) {
      const lastSegment = object.animateInfo.symbolPath[object.animateInfo.symbolPath.length - 1];
      const parentSegment = object.animateInfo.symbolPath[object.animateInfo.symbolPath.length - 2];
      const combinedName = `${parentSegment}_${lastSegment}`.replace(/\s+/g, '_');
      if (combinedName !== cleanName) {
        suggestions.push({
          name: combinedName,
          reason: `Symbol path: ${parentSegment} → ${lastSegment}`,
          confidence: 'medium',
          source: 'animate'
        });
      }
    }
  }

  if (hasAnimateFormatName && !object.animateInfo?.isAnimateFormat) {
    const cleanedName = object.rawId
      .replace(/_(FILL|STROKE)_?\d*$/i, '')
      .replace(/_Layer_?\d*_?MEMBER_?\d*$/i, '')
      .replace(/_MEMBER_?\d*$/i, '')
      .replace(/\s+/g, '_');
    
    if (cleanedName && cleanedName !== object.displayName && cleanedName !== object.rawId) {
      suggestions.push({
        name: cleanedName,
        reason: `Cleaned Animate export name`,
        confidence: 'high',
        source: 'animate'
      });
    }
  }

  if (object.instanceOf) {
    const instanceName = `${object.instanceOf}_Instance`.replace(/\s+/g, '_');
    suggestions.push({
      name: instanceName,
      reason: `Instance of symbol: ${object.instanceOf}`,
      confidence: 'high',
      source: 'hierarchy'
    });
  }

  if (object.children && object.children.length > 0) {
    const childTypes = new Map<string, number>();
    object.children.forEach(child => {
      const type = child.type;
      childTypes.set(type, (childTypes.get(type) || 0) + 1);
    });
    
    const dominantType = Array.from(childTypes.entries())
      .sort((a, b) => b[1] - a[1])[0];
    
    if (dominantType && dominantType[1] >= 2) {
      const pluralName = pluralizeType(dominantType[0]);
      suggestions.push({
        name: `${pluralName}_Container`,
        reason: `Contains ${dominantType[1]} ${pluralName.toLowerCase()}`,
        confidence: 'medium',
        source: 'hierarchy'
      });
    }
    
    const meaningfulChild = object.children.find(c => !c.isAutoGenerated && c.displayName);
    if (meaningfulChild) {
      suggestions.push({
        name: `${meaningfulChild.displayName}_Parent`,
        reason: `Parent of: ${meaningfulChild.displayName}`,
        confidence: 'medium',
        source: 'hierarchy'
      });
    }
  }

  if (object.parentId && objectMap.has(object.parentId)) {
    const parent = objectMap.get(object.parentId)!;
    if (!parent.isAutoGenerated && parent.displayName) {
      const siblingIndex = parent.children?.findIndex(c => c.id === object.id) ?? 0;
      suggestions.push({
        name: `${parent.displayName}_${object.type}_${siblingIndex + 1}`,
        reason: `Child #${siblingIndex + 1} of ${parent.displayName}`,
        confidence: 'low',
        source: 'hierarchy'
      });
    }
  }

  const typeLabel = getTypeLabelForSuggestion(object.type);
  if (object.bounds) {
    const isWide = object.bounds.width > object.bounds.height * 2;
    const isTall = object.bounds.height > object.bounds.width * 2;
    const isSmall = object.bounds.width < 50 && object.bounds.height < 50;
    const isLarge = object.bounds.width > 200 || object.bounds.height > 200;
    
    let sizePrefix = '';
    if (isSmall) sizePrefix = 'Small_';
    else if (isLarge) sizePrefix = 'Large_';
    
    let shapePrefix = '';
    if (isWide) shapePrefix = 'Wide_';
    else if (isTall) shapePrefix = 'Tall_';
    
    if (sizePrefix || shapePrefix) {
      suggestions.push({
        name: `${sizePrefix}${shapePrefix}${typeLabel}`,
        reason: `${object.bounds.width.toFixed(0)}×${object.bounds.height.toFixed(0)}px ${object.type}`,
        confidence: 'low',
        source: 'visual'
      });
    }
  }

  if (object.fill && object.fill !== 'none' && object.fill !== 'transparent') {
    const colorName = getColorName(object.fill);
    if (colorName) {
      suggestions.push({
        name: `${colorName}_${typeLabel}`,
        reason: `${colorName} colored ${object.type}`,
        confidence: 'low',
        source: 'visual'
      });
    }
  }

  if (siblingObjects && siblingObjects.length > 1) {
    const index = siblingObjects.findIndex(s => s.id === object.id);
    if (index >= 0) {
      const position = getPositionalName(object, siblingObjects);
      if (position) {
        suggestions.push({
          name: `${position}_${typeLabel}`,
          reason: `Position in sibling group`,
          confidence: 'low',
          source: 'sibling'
        });
      }
    }
  }

  const seen = new Set<string>();
  return suggestions.filter(s => {
    const key = s.name.toLowerCase();
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  }).slice(0, 5);
}

function pluralizeType(type: string): string {
  const plurals: Record<string, string> = {
    'path': 'Paths',
    'group': 'Groups',
    'rect': 'Rectangles',
    'circle': 'Circles',
    'ellipse': 'Ellipses',
    'polygon': 'Polygons',
    'text': 'Text_Elements',
    'use': 'Instances'
  };
  return plurals[type] || `${type}s`;
}

function getTypeLabelForSuggestion(type: string): string {
  const labels: Record<string, string> = {
    'path': 'Shape',
    'group': 'Group',
    'rect': 'Rectangle',
    'circle': 'Circle',
    'ellipse': 'Ellipse',
    'polygon': 'Polygon',
    'text': 'Text',
    'use': 'Instance'
  };
  return labels[type] || 'Element';
}

function getColorName(color: string): string | null {
  const colorMap: Record<string, string> = {
    '#000000': 'Black', '#000': 'Black',
    '#ffffff': 'White', '#fff': 'White',
    '#ff0000': 'Red', '#f00': 'Red',
    '#00ff00': 'Green', '#0f0': 'Green',
    '#0000ff': 'Blue', '#00f': 'Blue',
    '#ffff00': 'Yellow', '#ff0': 'Yellow',
    '#ff00ff': 'Magenta', '#f0f': 'Magenta',
    '#00ffff': 'Cyan', '#0ff': 'Cyan',
    '#808080': 'Gray', 'gray': 'Gray', 'grey': 'Gray',
    'black': 'Black', 'white': 'White', 'red': 'Red',
    'green': 'Green', 'blue': 'Blue', 'yellow': 'Yellow'
  };
  return colorMap[color.toLowerCase()] || null;
}

function getPositionalName(object: SVGObject, siblings: SVGObject[]): string | null {
  if (!object.bounds || siblings.length < 2) return null;
  
  const sorted = siblings
    .filter(s => s.bounds)
    .sort((a, b) => (a.bounds?.x ?? 0) - (b.bounds?.x ?? 0));
  
  const index = sorted.findIndex(s => s.id === object.id);
  if (index === 0) return 'Left';
  if (index === sorted.length - 1) return 'Right';
  
  const sortedY = siblings
    .filter(s => s.bounds)
    .sort((a, b) => (a.bounds?.y ?? 0) - (b.bounds?.y ?? 0));
  
  const indexY = sortedY.findIndex(s => s.id === object.id);
  if (indexY === 0) return 'Top';
  if (indexY === sortedY.length - 1) return 'Bottom';
  
  return `Item_${index + 1}`;
}

function generateAllSuggestions(
  objects: SVGObject[],
  objectMap: Map<string, SVGObject>
): Map<string, NameSuggestion[]> {
  const suggestionsMap = new Map<string, NameSuggestion[]>();
  
  function traverse(objs: SVGObject[], siblings?: SVGObject[]) {
    objs.forEach(obj => {
      const suggestions = generateNameSuggestions(obj, objectMap, siblings);
      if (suggestions.length > 0) {
        suggestionsMap.set(obj.id, suggestions);
      }
      if (obj.children && obj.children.length > 0) {
        traverse(obj.children, obj.children);
      }
    });
  }
  
  traverse(objects, objects);
  return suggestionsMap;
}

interface SelectionContextValue {
  state: {
    selectedIds: Set<string>;
    focusedObjectId: string | null;
    isolatedGroupId: string | null;
    isolationDepth: number;
    selectionLineage: SelectionLineage[];
    lastClickedId: string | null;
    lastClickTime: number;
  };
  selectOne: (id: string, lineage?: SelectionLineage[]) => void;
  toggleSelect: (id: string) => void;
  addToSelection: (ids: string[]) => void;
  addRange: (fromId: string, toId: string, allIds: string[]) => void;
  replaceSelection: (ids: string[]) => void;
  clearSelection: () => void;
  setFocused: (id: string | null) => void;
  enterIsolation: (groupId: string, groupName: string, depth?: number) => void;
  exitIsolation: () => void;
  exitToRoot: () => void;
  setLineage: (lineage: SelectionLineage[]) => void;
  recordClick: (id: string) => void;
  isDoubleClick: (id: string) => boolean;
  isSelected: (id: string) => boolean;
  isFocused: (id: string) => boolean;
  isIsolated: (id: string) => boolean;
  isInsideIsolation: (objectId: string, objectParentId: string | undefined, objectMap: Map<string, any>) => boolean;
}

interface ObjectTreeItemProps {
  object: SVGObject;
  isExpanded: boolean;
  onToggle: () => void;
  onSelect: (e?: React.MouseEvent) => void;
  level: number;
  expandedIds: Set<string>;
  onToggleChild: (id: string) => void;
  onSelectChild: (obj: SVGObject, e?: React.MouseEvent) => void;
  getDisplayName: (obj: SVGObject) => string;
  onUngroup?: (id: string, name: string) => void;
  ungroupedIds?: Set<string>;
  selection: SelectionContextValue;
}

function ObjectTreeItem({ 
  object, 
  isExpanded, 
  onToggle, 
  onSelect, 
  level,
  expandedIds,
  onToggleChild,
  onSelectChild,
  getDisplayName,
  onUngroup,
  ungroupedIds,
  selection
}: ObjectTreeItemProps) {
  const hasChildren = object.children && object.children.length > 0;
  const displayName = getDisplayName(object);
  const isUngrouped = ungroupedIds?.has(object.id) ?? false;
  const canUngroup = object.type === 'group' && hasChildren && !isUngrouped;
  const isSelected = selection.isSelected(object.id);
  const isFocused = selection.isFocused(object.id);

  return (
    <div data-testid={`tree-node-${object.id}`}>
      <div
        className={cn(
          "flex items-center gap-1 px-2 py-1 rounded cursor-pointer hover:bg-muted/50 group/item transition-colors",
          isSelected && !isFocused && "bg-[#0D99FF]/10 border border-[#0D99FF]/20",
          isFocused && "bg-[#0D99FF]/15 border border-[#0D99FF]/40 ring-1 ring-[#0D99FF]/30"
        )}
        style={{ paddingLeft: `${level * 12 + 8}px` }}
        onClick={(e) => onSelect(e)}
        data-testid={`tree-item-${object.id}`}
      >
        {hasChildren ? (
          <Button
            variant="ghost"
            size="sm"
            className="h-4 w-4 p-0"
            onClick={(e) => {
              e.stopPropagation();
              onToggle();
            }}
            data-testid={`tree-toggle-${object.id}`}
          >
            {isExpanded ? (
              <ChevronDown className="w-3 h-3" />
            ) : (
              <ChevronRight className="w-3 h-3" />
            )}
          </Button>
        ) : (
          <div className="w-4" />
        )}
        
        <ObjectIcon type={object.type} />
        
        <span className={cn(
          "text-xs flex-1 truncate",
          object.isAutoGenerated && "text-muted-foreground italic"
        )}>
          {displayName}
        </span>
        
        {object.isSymbolInstance && object.instanceOf && (
          <span 
            className="text-[9px] text-cyan-600 dark:text-cyan-400 truncate max-w-[80px]"
            title={`Instance of: ${object.instanceOf}`}
          >
            ⟶ {object.instanceOf}
          </span>
        )}
        
        {object.isAutoGenerated && (
          <AlertCircle className="w-3 h-3 text-amber-500 opacity-60" />
        )}
        
        {canUngroup && (
          <Button
            variant="ghost"
            size="sm"
            className="h-4 w-4 p-0 opacity-0 group-hover/item:opacity-100 transition-opacity"
            onClick={(e) => {
              e.stopPropagation();
              onUngroup?.(object.id, displayName);
            }}
            title="Ungroup (keep name on children)"
            data-testid={`button-ungroup-${object.id}`}
          >
            <Ungroup className="w-3 h-3 text-purple-500" />
          </Button>
        )}
        
        <Badge variant="outline" className={cn(
          "text-[10px] px-1 py-0",
          object.type === 'use' && "bg-cyan-500/10 border-cyan-500/30 text-cyan-700 dark:text-cyan-300"
        )}>
          {object.type === 'use' ? 'instance' : object.type}
        </Badge>
      </div>

      {hasChildren && isExpanded && (
        <div>
          {object.children!.map((child) => (
            <ObjectTreeItem
              key={child.id}
              object={child}
              isExpanded={expandedIds.has(child.id)}
              onToggle={() => onToggleChild(child.id)}
              onSelect={(e) => onSelectChild(child, e)}
              level={level + 1}
              expandedIds={expandedIds}
              onToggleChild={onToggleChild}
              onSelectChild={onSelectChild}
              getDisplayName={getDisplayName}
              onUngroup={onUngroup}
              ungroupedIds={ungroupedIds}
              selection={selection}
            />
          ))}
        </div>
      )}
    </div>
  );
}

function ObjectIcon({ type }: { type: string }) {
  switch (type) {
    case 'group':
      return <Layers className="w-3 h-3 text-purple-500" />;
    case 'path':
      return <Move className="w-3 h-3 text-blue-500" />;
    case 'use':
      return <GitBranch className="w-3 h-3 text-cyan-500" />;
    case 'rect':
    case 'circle':
    case 'ellipse':
    case 'polygon':
      return <Box className="w-3 h-3 text-green-500" />;
    case 'text':
      return <Tag className="w-3 h-3 text-orange-500" />;
    default:
      return <Box className="w-3 h-3 text-gray-500" />;
  }
}

function CopyButton({ text, label }: { text: string; label?: string }) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    await navigator.clipboard.writeText(text);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <Button 
      variant="ghost" 
      size="sm" 
      className="h-5 w-5 p-0" 
      onClick={handleCopy}
      title={label || `Copy "${text}"`}
    >
      {copied ? (
        <Check className="w-3 h-3 text-green-500" />
      ) : (
        <Copy className="w-3 h-3 text-muted-foreground" />
      )}
    </Button>
  );
}

function sanitizeSVGMarkup(markup: string): string {
  const container = document.createElement('div');
  container.innerHTML = markup;
  
  const removeScriptsAndEvents = (element: Element) => {
    if (element.tagName.toLowerCase() === 'script') {
      element.remove();
      return;
    }
    
    Array.from(element.attributes).forEach(attr => {
      if (attr.name.toLowerCase().startsWith('on') || 
          attr.value.toLowerCase().includes('javascript:')) {
        element.removeAttribute(attr.name);
      }
    });
    
    Array.from(element.children).forEach(child => removeScriptsAndEvents(child));
  };
  
  Array.from(container.children).forEach(child => removeScriptsAndEvents(child));
  return container.innerHTML;
}

interface ObjectPreviewProps {
  object: SVGObject;
  defsMarkup: string;
  rootViewBox?: { width: number; height: number };
}

function ObjectPreview({ object, defsMarkup, rootViewBox }: ObjectPreviewProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [computedBounds, setComputedBounds] = useState<{ x: number; y: number; width: number; height: number } | null>(null);
  const [sanitizedMarkup, setSanitizedMarkup] = useState<string>('');
  const [sanitizedDefs, setSanitizedDefs] = useState<string>('');
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!object.originalMarkup) {
      setError("No preview available");
      return;
    }

    const safeMarkup = sanitizeSVGMarkup(object.originalMarkup);
    const safeDefs = defsMarkup ? sanitizeSVGMarkup(defsMarkup) : '';
    
    setSanitizedMarkup(safeMarkup);
    setSanitizedDefs(safeDefs);

    const offscreenContainer = document.createElement('div');
    offscreenContainer.style.position = 'absolute';
    offscreenContainer.style.left = '-9999px';
    offscreenContainer.style.top = '-9999px';
    offscreenContainer.style.visibility = 'hidden';
    document.body.appendChild(offscreenContainer);

    try {
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", "4000");
      svg.setAttribute("height", "4000");
      
      if (safeDefs) {
        const defsContainer = document.createElement('div');
        defsContainer.innerHTML = `<svg xmlns="${svgNS}">${safeDefs}</svg>`;
        const defsElement = defsContainer.querySelector('defs');
        if (defsElement) {
          svg.appendChild(defsElement.cloneNode(true));
        }
      }

      const wrapper = document.createElementNS(svgNS, "g");
      wrapper.innerHTML = safeMarkup;
      svg.appendChild(wrapper);
      
      offscreenContainer.appendChild(svg);

      const bbox = wrapper.getBBox();
      
      if (bbox.width > 0 && bbox.height > 0) {
        setComputedBounds({
          x: bbox.x,
          y: bbox.y,
          width: bbox.width,
          height: bbox.height
        });
        setError(null);
      } else if (rootViewBox) {
        setComputedBounds({ x: 0, y: 0, width: rootViewBox.width, height: rootViewBox.height });
      } else {
        setComputedBounds(object.bounds || { x: 0, y: 0, width: 100, height: 100 });
      }
    } catch (e) {
      console.error("Error computing bounds:", e);
      if (rootViewBox) {
        setComputedBounds({ x: 0, y: 0, width: rootViewBox.width, height: rootViewBox.height });
      } else {
        setComputedBounds(object.bounds || { x: 0, y: 0, width: 100, height: 100 });
      }
    } finally {
      document.body.removeChild(offscreenContainer);
    }
  }, [object.originalMarkup, object.bounds, defsMarkup, rootViewBox]);

  if (error && !object.originalMarkup) {
    return (
      <div className="bg-muted/30 rounded-lg border p-4 text-center">
        <Box className="w-8 h-8 mx-auto text-muted-foreground mb-2" />
        <p className="text-xs text-muted-foreground">{error}</p>
      </div>
    );
  }

  if (!computedBounds || !sanitizedMarkup) {
    return (
      <div className="bg-muted/30 rounded-lg border p-4 text-center">
        <div className="w-8 h-8 mx-auto mb-2 animate-pulse bg-muted rounded" />
        <p className="text-xs text-muted-foreground">Computing preview...</p>
      </div>
    );
  }

  const padding = Math.max(10, Math.min(computedBounds.width, computedBounds.height) * 0.1);
  const viewBoxWidth = computedBounds.width + padding * 2;
  const viewBoxHeight = computedBounds.height + padding * 2;
  const viewBox = `${computedBounds.x - padding} ${computedBounds.y - padding} ${viewBoxWidth} ${viewBoxHeight}`;

  return (
    <div className="bg-muted/30 rounded-lg border p-2" ref={containerRef}>
      <div 
        className="relative w-full aspect-square flex items-center justify-center rounded overflow-hidden"
        style={{ 
          backgroundImage: 'linear-gradient(45deg, #e5e5e5 25%, transparent 25%), linear-gradient(-45deg, #e5e5e5 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #e5e5e5 75%), linear-gradient(-45deg, transparent 75%, #e5e5e5 75%)',
          backgroundSize: '16px 16px',
          backgroundPosition: '0 0, 0 8px, 8px -8px, -8px 0px'
        }}
      >
        <svg
          viewBox={viewBox}
          className="w-full h-full max-w-[200px] max-h-[200px]"
          preserveAspectRatio="xMidYMid meet"
          dangerouslySetInnerHTML={{
            __html: `${sanitizedDefs}${sanitizedMarkup}`
          }}
        />
      </div>
      <div className="text-center text-xs text-muted-foreground mt-2">
        {computedBounds.width.toFixed(0)} × {computedBounds.height.toFixed(0)} px
      </div>
    </div>
  );
}

interface ObjectDetailsProps {
  object: SVGObject;
  gradients: SVGGradient[];
  defsMarkup: string;
  rootViewBox?: { width: number; height: number };
  lineage: SVGObject[];
  displayName: string;
  onRename: (newName: string) => void;
  suggestions?: NameSuggestion[];
  onApplySuggestion?: (name: string) => void;
  onNavigateToParent?: (obj: SVGObject) => void;
  getParentDisplayName?: (obj: SVGObject) => string;
}

function ObjectDetails({ object, gradients, defsMarkup, rootViewBox, lineage, displayName, onRename, suggestions, onApplySuggestion, onNavigateToParent, getParentDisplayName }: ObjectDetailsProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(displayName);
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    setEditValue(displayName);
  }, [displayName]);

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  const handleSave = () => {
    if (editValue.trim() && editValue !== displayName) {
      onRename(editValue.trim());
    } else {
      setEditValue(displayName);
    }
    setIsEditing(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleSave();
    } else if (e.key === 'Escape') {
      setEditValue(displayName);
      setIsEditing(false);
    }
  };

  const gradient = object.gradientId 
    ? gradients.find(g => g.id === object.gradientId)
    : null;

  const nameSourceLabels: Record<NameSource, string> = {
    'data-name': 'data-name',
    'aria-label': 'aria-label', 
    'id': 'id',
    'title': 'title',
    'class': 'class',
    'auto-generated': 'Auto-generated'
  };

  const [overviewOpen, setOverviewOpen] = useState(true);
  const [geometryOpen, setGeometryOpen] = useState(true);
  const [appearanceOpen, setAppearanceOpen] = useState(true);
  const [sourceOpen, setSourceOpen] = useState(false);
  const [suggestionsOpen, setSuggestionsOpen] = useState(true);

  const confidenceColors: Record<NameSuggestion['confidence'], string> = {
    high: 'bg-green-500/20 text-green-700 dark:text-green-300 border-green-500/30',
    medium: 'bg-yellow-500/20 text-yellow-700 dark:text-yellow-300 border-yellow-500/30',
    low: 'bg-gray-500/20 text-gray-700 dark:text-gray-300 border-gray-500/30'
  };

  return (
    <div className="p-3 space-y-3">
      {lineage.length > 0 && onNavigateToParent && (
        <div className="flex items-center gap-1 text-[10px] text-muted-foreground overflow-x-auto pb-1">
          <span className="text-muted-foreground/60">Path:</span>
          {lineage.map((parent, idx) => (
            <React.Fragment key={parent.id}>
              {idx > 0 && <ChevronRight className="w-2.5 h-2.5 shrink-0" />}
              <button
                className="hover:text-[#0D99FF] hover:underline truncate max-w-[100px]"
                onClick={() => onNavigateToParent(parent)}
                title={`Navigate to ${getParentDisplayName?.(parent) || parent.displayName}`}
              >
                {getParentDisplayName?.(parent) || parent.displayName}
              </button>
            </React.Fragment>
          ))}
          <ChevronRight className="w-2.5 h-2.5 shrink-0" />
          <span className="text-foreground font-medium truncate max-w-[100px]">{displayName}</span>
        </div>
      )}
      
      <div className="space-y-2">
        <div className="flex items-center gap-2">
          {isEditing ? (
            <Input
              ref={inputRef}
              value={editValue}
              onChange={(e) => setEditValue(e.target.value)}
              onBlur={handleSave}
              onKeyDown={handleKeyDown}
              className="h-8 text-sm font-semibold flex-1"
              data-testid="input-object-name"
            />
          ) : (
            <>
              <h3 className={cn(
                "text-sm font-semibold flex-1 truncate",
                object.isAutoGenerated && "text-muted-foreground"
              )}>
                {displayName}
              </h3>
              <Button
                variant="ghost"
                size="sm"
                className="h-6 w-6 p-0"
                onClick={() => setIsEditing(true)}
                title="Rename object"
                data-testid="button-rename-object"
              >
                <Pencil className="w-3 h-3" />
              </Button>
              <CopyButton text={displayName} label="Copy display name" />
            </>
          )}
        </div>
        <div className="flex items-center gap-2 flex-wrap">
          <Badge className={cn(
            "text-[10px]",
            object.type === 'use' && "bg-cyan-500/20 text-cyan-700 dark:text-cyan-300 border-cyan-500/30"
          )}>
            {object.type === 'use' ? 'Instance' : object.type}
          </Badge>
          {object.children && object.children.length > 0 && (
            <Badge variant="outline" className="text-[10px]">
              {object.children.length} children
            </Badge>
          )}
          <Badge variant="outline" className="text-[10px]">
            {nameSourceLabels[object.nameSource]}
          </Badge>
        </div>
      </div>

      {suggestions && suggestions.length > 0 && (
        <Collapsible open={suggestionsOpen} onOpenChange={setSuggestionsOpen}>
          <CollapsibleTrigger className="flex items-center justify-between w-full p-2 rounded-lg bg-gradient-to-r from-purple-500/10 to-blue-500/10 hover:from-purple-500/20 hover:to-blue-500/20 transition-colors border border-purple-500/20">
            <div className="flex items-center gap-2 text-xs font-medium">
              <Sparkles className="w-3 h-3 text-purple-500" />
              <span>Suggested Names</span>
              <Badge className="text-[9px] px-1 py-0 bg-purple-500/20 text-purple-700 dark:text-purple-300 border-purple-500/30">
                {suggestions.length}
              </Badge>
            </div>
            {suggestionsOpen ? <ChevronDown className="w-3 h-3" /> : <ChevronRight className="w-3 h-3" />}
          </CollapsibleTrigger>
          <CollapsibleContent className="pt-2 space-y-1.5">
            {suggestions.map((suggestion, i) => (
              <div 
                key={`${suggestion.name}-${i}`}
                className="flex items-center gap-2 p-2 rounded-lg bg-muted/30 border hover:bg-muted/50 transition-colors group"
              >
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2">
                    <span className="text-xs font-medium truncate">{suggestion.name}</span>
                    <Badge 
                      variant="outline" 
                      className={cn("text-[9px] px-1 py-0 shrink-0", confidenceColors[suggestion.confidence])}
                    >
                      {suggestion.confidence}
                    </Badge>
                  </div>
                  <p className="text-[10px] text-muted-foreground truncate mt-0.5" title={suggestion.reason}>
                    {suggestion.reason}
                  </p>
                </div>
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-6 px-2 text-[10px] shrink-0 opacity-0 group-hover:opacity-100 transition-opacity"
                  onClick={() => onApplySuggestion?.(suggestion.name)}
                  data-testid={`button-apply-suggestion-${i}`}
                >
                  <CheckCircle2 className="w-3 h-3 mr-1" />
                  Apply
                </Button>
              </div>
            ))}
          </CollapsibleContent>
        </Collapsible>
      )}
        
      {object.isSymbolInstance && object.instanceOf && (
        <div className="p-2 bg-cyan-500/10 rounded-lg border border-cyan-500/20">
          <div className="flex items-center gap-2 text-xs">
            <GitBranch className="w-3 h-3 text-cyan-600 dark:text-cyan-400" />
            <span className="text-muted-foreground">Instance of:</span>
            <span className="font-medium text-cyan-700 dark:text-cyan-300">{object.instanceOf}</span>
            <CopyButton text={object.instanceOf} label="Copy symbol name" />
          </div>
          {object.symbolId && object.symbolId !== object.instanceOf && (
            <div className="flex items-center gap-2 text-xs mt-1 pl-5">
              <span className="text-muted-foreground">Symbol ID:</span>
              <span className="font-mono text-[11px]">{object.symbolId}</span>
              <CopyButton text={object.symbolId} label="Copy symbol ID" />
            </div>
          )}
        </div>
      )}
      
      {object.symbolPath && object.symbolPath.length > 1 && (
        <div className="p-2 bg-amber-500/10 rounded-lg border border-amber-500/20">
          <div className="text-[10px] text-muted-foreground uppercase tracking-wide mb-1">Symbol Path</div>
          <div className="flex flex-wrap gap-1 items-center text-xs">
            {object.symbolPath.map((symbol, i) => (
              <React.Fragment key={`${symbol}-${i}`}>
                <span className={cn(
                  "px-1.5 py-0.5 rounded",
                  i === object.symbolPath!.length - 1 
                    ? "bg-amber-500/20 text-amber-700 dark:text-amber-300 font-medium" 
                    : "bg-muted text-muted-foreground"
                )}>
                  {formatAnimateDisplayName(symbol)}
                </span>
                {i < object.symbolPath!.length - 1 && (
                  <ChevronRight className="w-3 h-3 text-muted-foreground" />
                )}
              </React.Fragment>
            ))}
          </div>
        </div>
      )}
      
      {object.animateInfo?.isAnimateFormat && (
        <div className="p-2 bg-purple-500/10 rounded-lg border border-purple-500/20">
          <div className="text-[10px] text-muted-foreground uppercase tracking-wide mb-1">Animate Export Info</div>
          <div className="space-y-1 text-xs">
            {object.animateInfo.layerInfo && (
              <div className="flex items-center gap-2">
                <Layers className="w-3 h-3 text-purple-600 dark:text-purple-400" />
                <span className="text-muted-foreground">Layer:</span>
                <span className="text-purple-700 dark:text-purple-300">{object.animateInfo.layerInfo}</span>
              </div>
            )}
            {object.animateInfo.memberIndex !== undefined && (
              <div className="flex items-center gap-2">
                <Box className="w-3 h-3 text-purple-600 dark:text-purple-400" />
                <span className="text-muted-foreground">Member:</span>
                <span className="text-purple-700 dark:text-purple-300">#{object.animateInfo.memberIndex}</span>
              </div>
            )}
            {object.animateInfo.fillOrStroke && (
              <div className="flex items-center gap-2">
                <Palette className="w-3 h-3 text-purple-600 dark:text-purple-400" />
                <span className="text-muted-foreground">Type:</span>
                <Badge variant="outline" className="text-[10px] px-1 py-0">
                  {object.animateInfo.fillOrStroke}
                </Badge>
              </div>
            )}
          </div>
        </div>
      )}

      <ObjectPreview object={object} defsMarkup={defsMarkup} rootViewBox={rootViewBox} />

      {/* Hierarchy Section */}
      <Collapsible open={overviewOpen} onOpenChange={setOverviewOpen}>
        <CollapsibleTrigger className="flex items-center justify-between w-full p-2 rounded-lg bg-muted/30 hover:bg-muted/50 transition-colors">
          <div className="flex items-center gap-2 text-xs font-medium">
            <GitBranch className="w-3 h-3" />
            Hierarchy
          </div>
          {overviewOpen ? <ChevronDown className="w-3 h-3" /> : <ChevronRight className="w-3 h-3" />}
        </CollapsibleTrigger>
        <CollapsibleContent className="pt-2 space-y-2">
          {lineage.length > 0 && (
            <div className="space-y-1 pl-2">
              <div className="text-[10px] text-muted-foreground uppercase tracking-wide">Lineage</div>
              <div className="flex flex-wrap gap-1 items-center text-xs">
                {lineage.map((ancestor, i) => (
                  <React.Fragment key={ancestor.id}>
                    <span className={cn(
                      "px-1.5 py-0.5 rounded bg-muted",
                      ancestor.isAutoGenerated && "text-muted-foreground italic"
                    )}>
                      {ancestor.displayName}
                    </span>
                    {i < lineage.length - 1 && (
                      <ChevronRight className="w-3 h-3 text-muted-foreground" />
                    )}
                  </React.Fragment>
                ))}
                <ChevronRight className="w-3 h-3 text-muted-foreground" />
                <span className="px-1.5 py-0.5 rounded bg-primary/10 text-primary font-medium">
                  {displayName}
                </span>
              </div>
            </div>
          )}

          {object.parentName && (
            <div className="space-y-1 pl-2">
              <div className="text-[10px] text-muted-foreground uppercase tracking-wide">Parent</div>
              <div className="flex items-center gap-2 text-xs">
                <ObjectIcon type={object.parentType || 'group'} />
                <span className="font-mono">{object.parentName}</span>
                <Badge variant="outline" className="text-[10px] px-1 py-0">
                  {object.parentType}
                </Badge>
              </div>
            </div>
          )}

          {object.children && object.children.length > 0 && (
            <div className="space-y-1 pl-2">
              <div className="text-[10px] text-muted-foreground uppercase tracking-wide">
                Children ({object.children.length})
              </div>
              <div className="space-y-0.5 max-h-24 overflow-y-auto">
                {object.children.slice(0, 5).map((child) => (
                  <div key={child.id} className="flex items-center gap-2 text-xs">
                    <ObjectIcon type={child.type} />
                    <span className={cn(
                      "font-mono truncate flex-1",
                      child.isAutoGenerated && "text-muted-foreground italic"
                    )}>
                      {child.displayName}
                    </span>
                    <Badge variant="outline" className="text-[10px] px-1 py-0 shrink-0">
                      {child.type}
                    </Badge>
                  </div>
                ))}
                {object.children.length > 5 && (
                  <div className="text-[10px] text-muted-foreground pl-5">
                    + {object.children.length - 5} more...
                  </div>
                )}
              </div>
            </div>
          )}
        </CollapsibleContent>
      </Collapsible>

      {/* Geometry Section */}
      {object.bounds && (
        <Collapsible open={geometryOpen} onOpenChange={setGeometryOpen}>
          <CollapsibleTrigger className="flex items-center justify-between w-full p-2 rounded-lg bg-muted/30 hover:bg-muted/50 transition-colors">
            <div className="flex items-center gap-2 text-xs font-medium">
              <Move className="w-3 h-3" />
              Geometry
            </div>
            {geometryOpen ? <ChevronDown className="w-3 h-3" /> : <ChevronRight className="w-3 h-3" />}
          </CollapsibleTrigger>
          <CollapsibleContent className="pt-2 pl-2">
            <div className="grid grid-cols-2 gap-2 text-xs">
              <div>
                <span className="text-muted-foreground">X:</span> {object.bounds.x.toFixed(2)}
              </div>
              <div>
                <span className="text-muted-foreground">Y:</span> {object.bounds.y.toFixed(2)}
              </div>
              <div>
                <span className="text-muted-foreground">Width:</span> {object.bounds.width.toFixed(2)}
              </div>
              <div>
                <span className="text-muted-foreground">Height:</span> {object.bounds.height.toFixed(2)}
              </div>
            </div>
          </CollapsibleContent>
        </Collapsible>
      )}

      {/* Appearance Section */}
      {(object.fill || gradient) && (
        <Collapsible open={appearanceOpen} onOpenChange={setAppearanceOpen}>
          <CollapsibleTrigger className="flex items-center justify-between w-full p-2 rounded-lg bg-muted/30 hover:bg-muted/50 transition-colors">
            <div className="flex items-center gap-2 text-xs font-medium">
              <Palette className="w-3 h-3" />
              Appearance
            </div>
            {appearanceOpen ? <ChevronDown className="w-3 h-3" /> : <ChevronRight className="w-3 h-3" />}
          </CollapsibleTrigger>
          <CollapsibleContent className="pt-2 pl-2 space-y-3">
            {object.fill && (
              <div className="space-y-1">
                <div className="text-[10px] text-muted-foreground uppercase tracking-wide">Fill</div>
                <div className="flex items-center gap-2">
                  <div 
                    className="w-6 h-6 rounded border"
                    style={{ backgroundColor: object.fill }}
                  />
                  <span className="text-xs font-mono">{object.fill}</span>
                </div>
              </div>
            )}
            {gradient && (
              <div className="space-y-1">
                <div className="text-[10px] text-muted-foreground uppercase tracking-wide">Gradient</div>
                <div className="text-xs space-y-1">
                  <div className="font-mono text-muted-foreground">{gradient.id}</div>
                  <div className="flex gap-1">
                    {gradient.stops.map((stop, i) => (
                      <div
                        key={i}
                        className="flex-1 h-6 rounded border"
                        style={{ backgroundColor: stop.color }}
                        title={`${stop.offset}: ${stop.color}`}
                      />
                    ))}
                  </div>
                </div>
              </div>
            )}
          </CollapsibleContent>
        </Collapsible>
      )}

      {/* Source Section */}
      {(object.pathData || object.rawId) && (
        <Collapsible open={sourceOpen} onOpenChange={setSourceOpen}>
          <CollapsibleTrigger className="flex items-center justify-between w-full p-2 rounded-lg bg-muted/30 hover:bg-muted/50 transition-colors">
            <div className="flex items-center gap-2 text-xs font-medium">
              <Tag className="w-3 h-3" />
              Source & Identity
            </div>
            {sourceOpen ? <ChevronDown className="w-3 h-3" /> : <ChevronRight className="w-3 h-3" />}
          </CollapsibleTrigger>
          <CollapsibleContent className="pt-2 pl-2 space-y-2">
            <div className="space-y-2 text-xs">
              <div className="flex items-center justify-between">
                <span className="text-muted-foreground">Raw ID:</span>
                <div className="flex items-center gap-1">
                  <span className="font-mono text-[11px] truncate max-w-[120px]">{object.rawId}</span>
                  <CopyButton text={object.rawId} label="Copy raw ID" />
                </div>
              </div>

              {object.className && (
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">Class:</span>
                  <span className="font-mono truncate max-w-[120px] text-[11px]" title={object.className}>
                    {object.className}
                  </span>
                </div>
              )}

              {object.dataName && (
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">data-name:</span>
                  <span className="font-mono text-[11px]">{object.dataName}</span>
                </div>
              )}

              {object.ariaLabel && (
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">aria-label:</span>
                  <span className="font-mono text-[11px]">{object.ariaLabel}</span>
                </div>
              )}
            </div>

            {object.pathData && (
              <div className="space-y-1 mt-2">
                <div className="text-[10px] text-muted-foreground uppercase tracking-wide">Path Data</div>
                <div className="text-[10px] font-mono bg-muted p-2 rounded max-h-24 overflow-auto">
                  {object.pathData.substring(0, 150)}
                  {object.pathData.length > 150 && '...'}
                </div>
              </div>
            )}

            {object.isAutoGenerated && (
              <div className="flex items-start gap-2 p-2 bg-amber-500/10 rounded border border-amber-500/20">
                <Info className="w-3 h-3 text-amber-500 mt-0.5 shrink-0" />
                <div className="text-[10px] text-amber-700 dark:text-amber-300">
                  Auto-generated name. Check parent or children for better naming context.
                </div>
              </div>
            )}
          </CollapsibleContent>
        </Collapsible>
      )}
    </div>
  );
}

interface ParseContext {
  globalCounter: number;
  objectMap: Map<string, SVGObject>;
  symbolRegistry: Map<string, SymbolDefinition>;
  sourceType: ImportSourceType;
}

function detectSourceType(svgContent: string, svg: Element, userSelectedSource: ImportSourceType): ImportSourceType {
  const hasAdobeAnimatePatterns = isAnimateExport(svgContent);
  
  const hasFigmaPatterns = Boolean(
    svg.getAttribute('data-figma-node') ||
    svgContent.includes('<!-- Generator: Figma') ||
    svgContent.includes('figma:') ||
    svg.querySelector('[data-figma-node]')
  );
  
  const hasIllustratorPatterns = Boolean(
    svgContent.includes('<!-- Generator: Adobe Illustrator') ||
    svgContent.includes('xmlns:i="&ns_ai;"') ||
    svgContent.includes('i:extraneous="self"') ||
    svg.querySelector('[id*="Artboard"]') ||
    svg.querySelector('[id*="Layer_"]')
  );
  
  if (hasAdobeAnimatePatterns) return 'animate';
  if (hasFigmaPatterns) return 'figma';
  if (hasIllustratorPatterns) return 'illustrator';
  
  return userSelectedSource;
}

function parseSVG(svgContent: string, sourceType: ImportSourceType = 'animate'): { 
  objects: SVGObject[]; 
  gradients: SVGGradient[];
  viewBox?: { width: number; height: number };
  defsMarkup: string;
  objectMap: Map<string, SVGObject>;
  symbolRegistry: Map<string, SymbolDefinition>;
  detectedSource: ImportSourceType;
} {
  const parser = new DOMParser();
  const doc = parser.parseFromString(svgContent, 'image/svg+xml');
  const svg = doc.querySelector('svg');
  const symbolRegistry = new Map<string, SymbolDefinition>();
  const context: ParseContext = {
    globalCounter: 0,
    objectMap: new Map<string, SVGObject>(),
    symbolRegistry,
    sourceType
  };
  
  if (!svg) {
    return { objects: [], gradients: [], defsMarkup: '', objectMap: context.objectMap, symbolRegistry, detectedSource: sourceType };
  }
  
  const detectedSource = detectSourceType(svgContent, svg, sourceType);
  context.sourceType = detectedSource;

  let viewBox;
  const viewBoxAttr = svg.getAttribute('viewBox');
  if (viewBoxAttr) {
    const parts = viewBoxAttr.split(/[\s,]+/).map(Number);
    if (parts.length >= 4) {
      viewBox = { width: parts[2], height: parts[3] };
    }
  }

  let defsMarkup = '';
  const defs = svg.querySelector('defs');
  if (defs) {
    defsMarkup = defs.outerHTML;
    
    buildSymbolRegistry(defs, symbolRegistry);
  }
  
  const symbols = svg.querySelectorAll(':scope > symbol');
  symbols.forEach(symbol => {
    const id = symbol.getAttribute('id');
    if (id) {
      const name = deriveSymbolName(symbol);
      symbolRegistry.set(id, { id, name, type: 'symbol', element: symbol });
    }
  });
  
  const topLevelGroups = svg.querySelectorAll(':scope > g[id]');
  topLevelGroups.forEach(group => {
    const id = group.getAttribute('id');
    if (id && !symbolRegistry.has(id)) {
      const name = deriveSymbolName(group);
      symbolRegistry.set(id, { id, name, type: 'g', element: group });
    }
  });

  const gradients: SVGGradient[] = [];
  if (defs) {
    const linearGradients = defs.querySelectorAll('linearGradient');
    linearGradients.forEach(grad => {
      const stops: Array<{ offset: string; color: string }> = [];
      grad.querySelectorAll('stop').forEach(stop => {
        stops.push({
          offset: stop.getAttribute('offset') || '0%',
          color: stop.getAttribute('stop-color') || '#000000'
        });
      });
      gradients.push({
        id: grad.getAttribute('id') || '',
        type: 'linear',
        stops,
        x1: grad.getAttribute('x1') || undefined,
        y1: grad.getAttribute('y1') || undefined,
        x2: grad.getAttribute('x2') || undefined,
        y2: grad.getAttribute('y2') || undefined,
      });
    });

    const radialGradients = defs.querySelectorAll('radialGradient');
    radialGradients.forEach(grad => {
      const stops: Array<{ offset: string; color: string }> = [];
      grad.querySelectorAll('stop').forEach(stop => {
        stops.push({
          offset: stop.getAttribute('offset') || '0%',
          color: stop.getAttribute('stop-color') || '#000000'
        });
      });
      gradients.push({
        id: grad.getAttribute('id') || '',
        type: 'radial',
        stops,
      });
    });
  }

  const flatObjects: SVGObject[] = [];
  const groups = svg.querySelectorAll(':scope > g');
  
  groups.forEach((group) => {
    const obj = parseElement(group, null, context);
    if (obj) flatObjects.push(obj);
  });

  const directElements = svg.querySelectorAll(':scope > path, :scope > rect, :scope > circle, :scope > ellipse, :scope > polygon, :scope > use');
  directElements.forEach((element) => {
    const obj = parseElement(element, null, context);
    if (obj) flatObjects.push(obj);
  });

  let objects: SVGObject[];
  if (detectedSource === 'animate') {
    const allFlatObjects = collectAllObjects(flatObjects);
    objects = buildAnimateHierarchy(allFlatObjects);
    
    if (objects.length === 0) {
      objects = flatObjects;
    } else {
      rebuildObjectMap(objects, context.objectMap);
    }
  } else {
    objects = flatObjects;
  }

  return { objects, gradients, viewBox, defsMarkup, objectMap: context.objectMap, symbolRegistry, detectedSource };
}

function rebuildObjectMap(objects: SVGObject[], objectMap: Map<string, SVGObject>): void {
  objectMap.clear();
  
  function traverse(obj: SVGObject) {
    objectMap.set(obj.id, obj);
    if (obj.children) {
      obj.children.forEach(traverse);
    }
  }
  
  objects.forEach(traverse);
}

function collectAllObjects(objects: SVGObject[]): SVGObject[] {
  const result: SVGObject[] = [];
  
  function traverse(obj: SVGObject) {
    result.push(obj);
    if (obj.children) {
      obj.children.forEach(traverse);
    }
  }
  
  objects.forEach(traverse);
  return result;
}

function buildSymbolRegistry(defs: Element, registry: Map<string, SymbolDefinition>): void {
  const symbols = defs.querySelectorAll('symbol');
  symbols.forEach(symbol => {
    const id = symbol.getAttribute('id');
    if (id) {
      const name = deriveSymbolName(symbol);
      registry.set(id, { id, name, type: 'symbol', element: symbol });
    }
  });
  
  const groups = defs.querySelectorAll('g[id]');
  groups.forEach(group => {
    const id = group.getAttribute('id');
    if (id && !registry.has(id)) {
      const name = deriveSymbolName(group);
      registry.set(id, { id, name, type: 'g', element: group });
    }
  });
  
  const clipPaths = defs.querySelectorAll('clipPath[id]');
  clipPaths.forEach(cp => {
    const id = cp.getAttribute('id');
    if (id) {
      registry.set(id, { id, name: id, type: 'clipPath', element: cp });
    }
  });
  
  const masks = defs.querySelectorAll('mask[id]');
  masks.forEach(mask => {
    const id = mask.getAttribute('id');
    if (id) {
      registry.set(id, { id, name: id, type: 'mask', element: mask });
    }
  });
}

function deriveSymbolName(element: Element): string {
  const dataName = element.getAttribute('data-name');
  if (dataName) return dataName;
  
  const ariaLabel = element.getAttribute('aria-label');
  if (ariaLabel) return ariaLabel;
  
  const id = element.getAttribute('id');
  if (id && !isAutoGeneratedId(id)) return id;
  
  const titleElement = element.querySelector(':scope > title');
  if (titleElement?.textContent) return titleElement.textContent;
  
  const className = element.getAttribute('class');
  if (className) {
    const firstClass = className.split(/\s+/)[0];
    if (firstClass && !isAutoGeneratedClass(firstClass)) return firstClass;
  }
  
  return id || 'Symbol';
}

function deriveDisplayName(element: Element, globalIndex: number): { 
  displayName: string; 
  nameSource: NameSource; 
  isAutoGenerated: boolean;
  rawId: string;
  uniqueKey: string;
  dataName?: string;
  ariaLabel?: string;
  className?: string;
} {
  const rawId = element.getAttribute('id') || '';
  const dataName = element.getAttribute('data-name') || undefined;
  const ariaLabel = element.getAttribute('aria-label') || undefined;
  const className = element.getAttribute('class') || undefined;
  const titleElement = element.querySelector(':scope > title');
  const title = titleElement?.textContent || undefined;

  const uniqueKey = `__node_${globalIndex}`;

  if (dataName) {
    return { displayName: dataName, nameSource: 'data-name', isAutoGenerated: false, rawId, uniqueKey, dataName, ariaLabel, className };
  }

  if (ariaLabel) {
    return { displayName: ariaLabel, nameSource: 'aria-label', isAutoGenerated: false, rawId, uniqueKey, dataName, ariaLabel, className };
  }

  if (rawId && !isAutoGeneratedId(rawId)) {
    return { displayName: rawId, nameSource: 'id', isAutoGenerated: false, rawId, uniqueKey, dataName, ariaLabel, className };
  }

  if (title) {
    return { displayName: title, nameSource: 'title', isAutoGenerated: false, rawId, uniqueKey, dataName, ariaLabel, className };
  }

  if (className) {
    const firstClass = className.split(/\s+/)[0];
    if (firstClass && !isAutoGeneratedClass(firstClass)) {
      return { displayName: firstClass, nameSource: 'class', isAutoGenerated: false, rawId, uniqueKey, dataName, ariaLabel, className };
    }
  }

  const tagName = element.tagName.toLowerCase();
  const typeName = tagName === 'g' ? 'Group' : capitalize(tagName);
  const autoName = rawId || `${typeName}_${globalIndex}`;
  
  return { 
    displayName: autoName, 
    nameSource: 'auto-generated', 
    isAutoGenerated: true, 
    rawId: rawId || '',
    uniqueKey,
    dataName, 
    ariaLabel, 
    className 
  };
}

function isAutoGeneratedId(id: string): boolean {
  return /^(element_\d+|Layer_\d+|_\d+|g\d+|path\d+|rect\d+|circle\d+|ellipse\d+)$/i.test(id);
}

function isAutoGeneratedClass(className: string): boolean {
  return /^(st\d+|cls-\d+|fil\d+|str\d+)$/i.test(className);
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function parseAnimateId(id: string): AnimateIdInfo {
  const result: AnimateIdInfo = {
    isAnimateFormat: false,
    symbolPath: [],
    instanceName: id,
    cleanDisplayName: id
  };

  if (!id) return result;

  const isAnimatePattern = id.includes('_Assets_') || 
                           id.includes('_Layer') || 
                           id.includes('_MEMBER_') ||
                           id.includes('_FILL') ||
                           id.includes('_STROKE') ||
                           id.includes('_MASK');

  if (!isAnimatePattern) return result;

  result.isAnimateFormat = true;

  let workingId = id;
  
  if (workingId.endsWith('_FILL')) {
    result.fillOrStroke = 'FILL';
    workingId = workingId.slice(0, -5);
  } else if (workingId.endsWith('_STROKE')) {
    result.fillOrStroke = 'STROKE';
    workingId = workingId.slice(0, -7);
  }

  const memberMatch = workingId.match(/_MEMBER_(\d+)$/);
  if (memberMatch) {
    result.memberIndex = parseInt(memberMatch[1], 10);
    workingId = workingId.slice(0, memberMatch.index);
  }

  const layerMatch = workingId.match(/_(\d+)_Layer(\d+)_(\d+)$/);
  if (layerMatch) {
    result.layerInfo = `Layer${layerMatch[2]}`;
    workingId = workingId.slice(0, layerMatch.index);
  }

  const parts = workingId.split('_Assets_');
  
  if (parts.length > 1) {
    result.symbolPath = parts.map(part => cleanAnimateSymbolName(part));
    result.instanceName = result.symbolPath[result.symbolPath.length - 1];
    
    if (result.symbolPath.length >= 2) {
      result.parentSymbol = result.symbolPath[result.symbolPath.length - 2];
    }
  } else {
    result.symbolPath = [cleanAnimateSymbolName(workingId)];
    result.instanceName = result.symbolPath[0];
  }

  result.cleanDisplayName = formatAnimateDisplayName(result.instanceName);

  return result;
}

function cleanAnimateSymbolName(name: string): string {
  let cleaned = name
    .replace(/_\d+_Layer\d+_\d+$/, '')
    .replace(/_\d+$/, '')
    .replace(/_MEMBER_\d+$/, '')
    .replace(/_FILL$/, '')
    .replace(/_STROKE$/, '')
    .replace(/_MASK$/, '');
  
  return cleaned;
}

function formatAnimateDisplayName(name: string): string {
  return name
    .replace(/_/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function isAnimateExport(svgContent: string): boolean {
  return svgContent.includes('_Assets_') || 
         (svgContent.includes('_MEMBER_') && svgContent.includes('_FILL'));
}

interface AnimateSymbolNode {
  name: string;
  cleanName: string;
  path: string[];
  shapes: SVGObject[];
  children: Map<string, AnimateSymbolNode>;
  instanceOf?: string;
}

function buildAnimateHierarchy(objects: SVGObject[]): SVGObject[] {
  const rootMap = new Map<string, AnimateSymbolNode>();
  
  objects.forEach(obj => {
    if (!obj.animateInfo?.isAnimateFormat) return;
    
    const path = obj.animateInfo.symbolPath;
    if (path.length === 0) return;
    
    let currentMap = rootMap;
    let currentPath: string[] = [];
    
    for (let i = 0; i < path.length; i++) {
      const symbolName = path[i];
      currentPath = [...currentPath, symbolName];
      
      if (!currentMap.has(symbolName)) {
        currentMap.set(symbolName, {
          name: symbolName,
          cleanName: formatAnimateDisplayName(symbolName),
          path: currentPath,
          shapes: [],
          children: new Map(),
          instanceOf: i > 0 ? path[i - 1] : undefined
        });
      }
      
      const node = currentMap.get(symbolName)!;
      
      if (i === path.length - 1) {
        node.shapes.push(obj);
      }
      
      currentMap = node.children;
    }
  });

  return convertAnimateTreeToObjects(rootMap, null, 0);
}

function convertAnimateTreeToObjects(
  nodeMap: Map<string, AnimateSymbolNode>,
  parent: SVGObject | null,
  depth: number
): SVGObject[] {
  const result: SVGObject[] = [];
  let index = 0;
  
  nodeMap.forEach((node, key) => {
    const symbolObj: SVGObject = {
      id: `__animate_symbol_${node.path.join('_')}_${index}`,
      rawId: node.name,
      name: node.cleanName,
      displayName: node.cleanName,
      nameSource: 'id',
      isAutoGenerated: false,
      type: 'group',
      isSymbolInstance: !!node.instanceOf,
      instanceOf: node.instanceOf ? formatAnimateDisplayName(node.instanceOf) : undefined,
      symbolPath: node.path,
      animateInfo: {
        isAnimateFormat: true,
        symbolPath: node.path,
        instanceName: node.cleanName,
        parentSymbol: node.instanceOf,
        cleanDisplayName: node.cleanName
      },
      children: []
    };
    
    if (parent) {
      symbolObj.parentId = parent.id;
      symbolObj.parentName = parent.displayName;
      symbolObj.parentType = parent.type;
    }

    const childSymbols = convertAnimateTreeToObjects(node.children, symbolObj, depth + 1);
    
    const shapes = node.shapes.map((shape, shapeIdx) => ({
      ...shape,
      parentId: symbolObj.id,
      parentName: symbolObj.displayName,
      parentType: symbolObj.type
    }));
    
    symbolObj.children = [...childSymbols, ...shapes];
    
    if (symbolObj.children.length === 0) {
      delete symbolObj.children;
    }
    
    result.push(symbolObj);
    index++;
  });
  
  return result;
}

function parseElement(
  element: Element, 
  parent: SVGObject | null,
  context: ParseContext
): SVGObject | null {
  const tagName = element.tagName.toLowerCase();
  
  const globalIndex = context.globalCounter++;
  
  let type: SVGObject['type'] = 'path';
  if (tagName === 'g') type = 'group';
  else if (tagName === 'rect') type = 'rect';
  else if (tagName === 'circle') type = 'circle';
  else if (tagName === 'ellipse') type = 'ellipse';
  else if (tagName === 'polygon') type = 'polygon';
  else if (tagName === 'text') type = 'text';
  else if (tagName === 'use') type = 'use';

  const naming = deriveDisplayName(element, globalIndex);
  
  let instanceOf: string | undefined;
  let symbolId: string | undefined;
  let isSymbolInstance = false;
  
  if (tagName === 'use') {
    const href = element.getAttribute('href') || element.getAttribute('xlink:href');
    if (href && href.startsWith('#')) {
      symbolId = href.slice(1);
      const symbolDef = context.symbolRegistry.get(symbolId);
      if (symbolDef) {
        instanceOf = symbolDef.name;
        isSymbolInstance = true;
      } else {
        instanceOf = symbolId;
        isSymbolInstance = true;
      }
    }
  }
  
  const animateInfo = parseAnimateId(naming.rawId);
  
  if (animateInfo.isAnimateFormat && animateInfo.parentSymbol) {
    instanceOf = formatAnimateDisplayName(animateInfo.parentSymbol);
    isSymbolInstance = true;
  }
  
  let displayName = animateInfo.isAnimateFormat 
    ? animateInfo.cleanDisplayName 
    : naming.displayName;
  
  let nameSource = animateInfo.isAnimateFormat ? 'id' : naming.nameSource;
  let isAutoGenerated = animateInfo.isAnimateFormat ? false : naming.isAutoGenerated;
  
  if (context.sourceType === 'figma') {
    const figmaNode = element.getAttribute('data-figma-node');
    if (figmaNode) {
      nameSource = 'data-figma-node';
      isAutoGenerated = false;
    }
    if (naming.rawId && naming.rawId.match(/^[A-Za-z]+_\d+$/)) {
      displayName = naming.rawId.replace(/_\d+$/, '');
      nameSource = 'figma-pattern';
    }
    const clipPath = element.getAttribute('clip-path');
    if (clipPath && displayName.startsWith('auto-')) {
      displayName = 'Clipped Shape';
    }
  } else if (context.sourceType === 'illustrator') {
    if (naming.rawId) {
      if (naming.rawId.startsWith('Layer_')) {
        displayName = `Layer ${naming.rawId.replace('Layer_', '')}`;
        nameSource = 'illustrator-layer';
        isAutoGenerated = false;
      } else if (naming.rawId.startsWith('Artboard')) {
        displayName = naming.rawId.replace(/_/g, ' ');
        nameSource = 'illustrator-artboard';
        isAutoGenerated = false;
      } else if (naming.rawId.match(/^[A-Za-z]+_x[0-9A-Fa-f]+_/)) {
        const cleaned = naming.rawId.replace(/_x[0-9A-Fa-f]+_/g, ' ').trim();
        displayName = cleaned || displayName;
        nameSource = 'illustrator-encoded';
      }
    }
  }
  
  const obj: SVGObject = {
    id: naming.uniqueKey,
    rawId: naming.rawId,
    name: displayName,
    displayName: displayName,
    nameSource,
    isAutoGenerated,
    type,
    instanceOf,
    symbolId,
    isSymbolInstance,
    originalMarkup: element.outerHTML,
    dataName: naming.dataName,
    ariaLabel: naming.ariaLabel,
    className: naming.className,
    animateInfo: animateInfo.isAnimateFormat ? animateInfo : undefined,
    symbolPath: animateInfo.isAnimateFormat ? animateInfo.symbolPath : undefined,
  };

  if (parent) {
    obj.parentId = parent.id;
    obj.parentName = parent.displayName;
    obj.parentType = parent.type;
  }

  const fill = element.getAttribute('fill');
  if (fill && fill.startsWith('url(#')) {
    obj.gradientId = fill.slice(5, -1);
  } else if (fill) {
    obj.fill = fill;
  }

  const transform = element.getAttribute('transform');
  if (transform) {
    obj.transform = transform;
  }

  if (tagName === 'path') {
    const d = element.getAttribute('d');
    if (d) {
      obj.pathData = d;
      obj.bounds = estimatePathBounds(d);
    }
  }

  if (tagName === 'rect') {
    obj.bounds = {
      x: parseFloat(element.getAttribute('x') || '0'),
      y: parseFloat(element.getAttribute('y') || '0'),
      width: parseFloat(element.getAttribute('width') || '0'),
      height: parseFloat(element.getAttribute('height') || '0'),
    };
  } else if (tagName === 'circle') {
    const cx = parseFloat(element.getAttribute('cx') || '0');
    const cy = parseFloat(element.getAttribute('cy') || '0');
    const r = parseFloat(element.getAttribute('r') || '0');
    obj.bounds = { x: cx - r, y: cy - r, width: r * 2, height: r * 2 };
  } else if (tagName === 'ellipse') {
    const cx = parseFloat(element.getAttribute('cx') || '0');
    const cy = parseFloat(element.getAttribute('cy') || '0');
    const rx = parseFloat(element.getAttribute('rx') || '0');
    const ry = parseFloat(element.getAttribute('ry') || '0');
    obj.bounds = { x: cx - rx, y: cy - ry, width: rx * 2, height: ry * 2 };
  }

  if (tagName === 'use') {
    const x = parseFloat(element.getAttribute('x') || '0');
    const y = parseFloat(element.getAttribute('y') || '0');
    const width = parseFloat(element.getAttribute('width') || '100');
    const height = parseFloat(element.getAttribute('height') || '100');
    obj.bounds = { x, y, width, height };
  }

  const children: SVGObject[] = [];
  const childElements = element.querySelectorAll(':scope > g, :scope > path, :scope > rect, :scope > circle, :scope > ellipse, :scope > polygon, :scope > text, :scope > use');
  childElements.forEach((child) => {
    const childObj = parseElement(child, obj, context);
    if (childObj) children.push(childObj);
  });
  
  if (children.length > 0) {
    obj.children = children;
    
    if (type === 'group' && !obj.bounds) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      const aggregateBounds = (objs: SVGObject[]) => {
        objs.forEach(o => {
          if (o.bounds) {
            minX = Math.min(minX, o.bounds.x);
            minY = Math.min(minY, o.bounds.y);
            maxX = Math.max(maxX, o.bounds.x + o.bounds.width);
            maxY = Math.max(maxY, o.bounds.y + o.bounds.height);
          }
          if (o.children) aggregateBounds(o.children);
        });
      };
      aggregateBounds(children);
      
      if (isFinite(minX) && isFinite(minY) && isFinite(maxX) && isFinite(maxY)) {
        obj.bounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
      }
    }
  }

  context.objectMap.set(obj.id, obj);
  return obj;
}

function estimatePathBounds(pathData: string): { x: number; y: number; width: number; height: number } {
  const coords = pathData.match(/[-+]?[0-9]*\.?[0-9]+/g);
  if (!coords || coords.length === 0) {
    return { x: 0, y: 0, width: 100, height: 100 };
  }

  const numbers = coords.map(Number);
  const xs = numbers.filter((_, i) => i % 2 === 0);
  const ys = numbers.filter((_, i) => i % 2 === 1);

  if (xs.length === 0 || ys.length === 0) {
    return { x: 0, y: 0, width: 100, height: 100 };
  }

  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);

  return {
    x: minX,
    y: minY,
    width: Math.max(1, maxX - minX),
    height: Math.max(1, maxY - minY)
  };
}

function countObjects(objects: SVGObject[]): number {
  let count = objects.length;
  objects.forEach(obj => {
    if (obj.children) {
      count += countObjects(obj.children);
    }
  });
  return count;
}

function filterObjects(objects: SVGObject[], searchTerm: string): SVGObject[] {
  return objects.filter(obj => {
    if ((obj.displayName?.toLowerCase() || '').includes(searchTerm) ||
        (obj.rawId?.toLowerCase() || '').includes(searchTerm) ||
        (obj.className?.toLowerCase() || '').includes(searchTerm) ||
        (obj.instanceOf?.toLowerCase() || '').includes(searchTerm) ||
        (obj.symbolId?.toLowerCase() || '').includes(searchTerm)) {
      return true;
    }
    if (obj.children) {
      return filterObjects(obj.children, searchTerm).length > 0;
    }
    return false;
  });
}

interface SVGCanvasPreviewProps {
  svgContent: string;
  objects: SVGObject[];
  objectMap: Map<string, SVGObject>;
  selectedIds: Set<string>;
  isolatedGroupId: string | null;
  viewBox: { x: number; y: number; width: number; height: number } | null;
  onSelectObject: (obj: SVGObject, event?: React.MouseEvent) => void;
  getDisplayName: (obj: SVGObject) => string;
}

function SVGCanvasPreview({ 
  svgContent, 
  objects, 
  objectMap, 
  selectedIds, 
  isolatedGroupId,
  viewBox, 
  onSelectObject,
  getDisplayName
}: SVGCanvasPreviewProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const svgRef = useRef<SVGSVGElement | null>(null);
  const [zoom, setZoom] = useState(100);
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [hoveredId, setHoveredId] = useState<string | null>(null);
  
  const [isMarqueeSelecting, setIsMarqueeSelecting] = useState(false);
  const [marqueeStart, setMarqueeStart] = useState<{ x: number; y: number } | null>(null);
  const [marqueeEnd, setMarqueeEnd] = useState<{ x: number; y: number } | null>(null);
  
  const selection = useSelection();

  const flattenObjects = useCallback((objs: SVGObject[]): SVGObject[] => {
    const result: SVGObject[] = [];
    const traverse = (items: SVGObject[]) => {
      items.forEach(obj => {
        result.push(obj);
        if (obj.children) traverse(obj.children);
      });
    };
    traverse(objs);
    return result;
  }, []);

  const allObjects = useMemo(() => flattenObjects(objects), [objects, flattenObjects]);

  const isInsideIsolation = useCallback((obj: SVGObject): boolean => {
    if (!isolatedGroupId) return true;
    if (obj.id === isolatedGroupId) return true;
    let currentId = obj.parentId;
    while (currentId) {
      if (currentId === isolatedGroupId) return true;
      const parent = objectMap.get(currentId);
      currentId = parent?.parentId;
    }
    return false;
  }, [isolatedGroupId, objectMap]);

  const findObjectAtPoint = useCallback((clientX: number, clientY: number): SVGObject | null => {
    if (!containerRef.current || !svgRef.current) return null;
    
    const containerRect = containerRef.current.getBoundingClientRect();
    const svgRect = svgRef.current.getBoundingClientRect();
    
    const scale = zoom / 100;
    const svgX = (clientX - svgRect.left) / scale;
    const svgY = (clientY - svgRect.top) / scale;
    
    const matchingObjects = allObjects.filter(obj => {
      if (!obj.bounds) return false;
      if (!isInsideIsolation(obj)) return false;
      
      const { x, y, width, height } = obj.bounds;
      return svgX >= x && svgX <= x + width && svgY >= y && svgY <= y + height;
    });
    
    if (matchingObjects.length === 0) return null;
    
    matchingObjects.sort((a, b) => {
      const areaA = (a.bounds?.width || 0) * (a.bounds?.height || 0);
      const areaB = (b.bounds?.width || 0) * (b.bounds?.height || 0);
      return areaA - areaB;
    });
    
    return matchingObjects[0];
  }, [allObjects, zoom, isInsideIsolation]);

  const screenToSVG = useCallback((clientX: number, clientY: number): { x: number; y: number } | null => {
    if (!containerRef.current) return null;
    
    const containerRect = containerRef.current.getBoundingClientRect();
    const scale = zoom / 100;
    
    const x = (clientX - containerRect.left - pan.x) / scale;
    const y = (clientY - containerRect.top - pan.y) / scale;
    
    return { x, y };
  }, [zoom, pan]);

  const getObjectsInMarquee = useCallback((start: { x: number; y: number }, end: { x: number; y: number }): SVGObject[] => {
    const minX = Math.min(start.x, end.x);
    const maxX = Math.max(start.x, end.x);
    const minY = Math.min(start.y, end.y);
    const maxY = Math.max(start.y, end.y);
    
    return allObjects.filter(obj => {
      if (!obj.bounds) return false;
      if (!isInsideIsolation(obj)) return false;
      
      const { x, y, width, height } = obj.bounds;
      const objRight = x + width;
      const objBottom = y + height;
      
      return x < maxX && objRight > minX && y < maxY && objBottom > minY;
    });
  }, [allObjects, isInsideIsolation]);

  const handleCanvasClick = useCallback((e: React.MouseEvent) => {
    if (isPanning || isMarqueeSelecting) return;
    
    const obj = findObjectAtPoint(e.clientX, e.clientY);
    if (obj) {
      onSelectObject(obj, e);
    } else {
      selection.clearSelection();
    }
  }, [findObjectAtPoint, onSelectObject, isPanning, isMarqueeSelecting, selection]);

  const handleCanvasMouseMove = useCallback((e: React.MouseEvent) => {
    if (isPanning) {
      setPan({
        x: e.clientX - panStart.x,
        y: e.clientY - panStart.y
      });
      return;
    }
    
    if (isMarqueeSelecting) {
      const svgPos = screenToSVG(e.clientX, e.clientY);
      if (svgPos) {
        setMarqueeEnd(svgPos);
      }
      return;
    }
    
    const obj = findObjectAtPoint(e.clientX, e.clientY);
    setHoveredId(obj?.id || null);
  }, [findObjectAtPoint, isPanning, isMarqueeSelecting, panStart, screenToSVG]);

  const cancelMarquee = useCallback(() => {
    setIsMarqueeSelecting(false);
    setMarqueeStart(null);
    setMarqueeEnd(null);
  }, []);

  const isClickOnSelectionHandle = useCallback((clientX: number, clientY: number): boolean => {
    if (selectedObjects.length === 0) return false;
    
    const svgPos = screenToSVG(clientX, clientY);
    if (!svgPos) return false;
    
    const handleSize = 6 / scale;
    
    for (const obj of selectedObjects) {
      if (!obj.bounds) continue;
      const { x, y, width, height } = obj.bounds;
      
      const handles = [
        { x: x - 3 / scale, y: y - 3 / scale },
        { x: x + width - 3 / scale, y: y - 3 / scale },
        { x: x - 3 / scale, y: y + height - 3 / scale },
        { x: x + width - 3 / scale, y: y + height - 3 / scale },
      ];
      
      for (const handle of handles) {
        if (svgPos.x >= handle.x && svgPos.x <= handle.x + handleSize &&
            svgPos.y >= handle.y && svgPos.y <= handle.y + handleSize) {
          return true;
        }
      }
    }
    
    return false;
  }, [selectedObjects, screenToSVG, scale]);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (e.button === 1 || e.altKey) {
      setIsPanning(true);
      setPanStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
      e.preventDefault();
      return;
    }
    
    if (e.button === 0) {
      if (isClickOnSelectionHandle(e.clientX, e.clientY)) {
        return;
      }
      
      const obj = findObjectAtPoint(e.clientX, e.clientY);
      if (!obj) {
        const svgPos = screenToSVG(e.clientX, e.clientY);
        if (svgPos) {
          setIsMarqueeSelecting(true);
          setMarqueeStart(svgPos);
          setMarqueeEnd(svgPos);
        }
      }
    }
  }, [pan, findObjectAtPoint, screenToSVG, isClickOnSelectionHandle]);

  const completeMarquee = useCallback((shiftKey: boolean) => {
    if (marqueeStart && marqueeEnd) {
      const objectsInMarquee = getObjectsInMarquee(marqueeStart, marqueeEnd);
      
      if (objectsInMarquee.length > 0) {
        const ids = objectsInMarquee.map(obj => obj.id);
        
        if (shiftKey) {
          selection.addToSelection(ids);
        } else {
          selection.replaceSelection(ids);
        }
      } else if (!shiftKey) {
        selection.clearSelection();
      }
    }
    cancelMarquee();
  }, [marqueeStart, marqueeEnd, getObjectsInMarquee, selection, cancelMarquee]);

  const handleMouseUp = useCallback((e: React.MouseEvent) => {
    if (isMarqueeSelecting) {
      completeMarquee(e.shiftKey);
    }
    
    setIsPanning(false);
  }, [isMarqueeSelecting, completeMarquee]);
  
  useEffect(() => {
    if (!isMarqueeSelecting) return;
    
    const handleGlobalMouseMove = (e: MouseEvent) => {
      const svgPos = screenToSVG(e.clientX, e.clientY);
      if (svgPos) {
        setMarqueeEnd(svgPos);
      }
    };
    
    const handleGlobalMouseUp = (e: MouseEvent) => {
      completeMarquee(e.shiftKey);
    };
    
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        cancelMarquee();
      }
    };
    
    const handleBlur = () => {
      cancelMarquee();
    };
    
    document.addEventListener('mousemove', handleGlobalMouseMove);
    document.addEventListener('mouseup', handleGlobalMouseUp);
    document.addEventListener('keydown', handleKeyDown);
    window.addEventListener('blur', handleBlur);
    
    return () => {
      document.removeEventListener('mousemove', handleGlobalMouseMove);
      document.removeEventListener('mouseup', handleGlobalMouseUp);
      document.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('blur', handleBlur);
    };
  }, [isMarqueeSelecting, screenToSVG, completeMarquee, cancelMarquee]);

  const handleWheel = useCallback((e: React.WheelEvent) => {
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -10 : 10;
      setZoom(z => Math.max(25, Math.min(400, z + delta)));
    }
  }, []);

  useEffect(() => {
    if (containerRef.current) {
      const svgElement = containerRef.current.querySelector('svg');
      if (svgElement) {
        svgRef.current = svgElement as SVGSVGElement;
      }
    }
  }, [svgContent]);

  const selectedObjects = useMemo(() => 
    allObjects.filter(obj => selectedIds.has(obj.id)),
    [allObjects, selectedIds]
  );

  const width = viewBox?.width || 400;
  const height = viewBox?.height || 300;
  const scale = zoom / 100;

  return (
    <div className="flex flex-col h-full">
      <div className="flex items-center justify-between p-2 border-b bg-muted/30">
        <span className="text-xs font-medium text-muted-foreground">Canvas Preview</span>
        <div className="flex items-center gap-2">
          <Button
            variant="ghost"
            size="sm"
            className="h-6 w-6 p-0"
            onClick={() => setZoom(z => Math.max(25, z - 25))}
            data-testid="button-zoom-out-preview"
          >
            <ZoomIn className="w-3 h-3 rotate-180" />
          </Button>
          <span className="text-xs w-10 text-center">{zoom}%</span>
          <Button
            variant="ghost"
            size="sm"
            className="h-6 w-6 p-0"
            onClick={() => setZoom(z => Math.min(400, z + 25))}
            data-testid="button-zoom-in-preview"
          >
            <ZoomIn className="w-3 h-3" />
          </Button>
          <Button
            variant="ghost"
            size="sm"
            className="h-6 px-2 text-xs"
            onClick={() => { setZoom(100); setPan({ x: 0, y: 0 }); }}
            data-testid="button-reset-zoom-preview"
          >
            Reset
          </Button>
        </div>
      </div>
      
      <div 
        ref={containerRef}
        className="flex-1 overflow-hidden bg-[#1a1a1a] relative"
        style={{ cursor: isPanning ? 'grabbing' : isMarqueeSelecting ? 'crosshair' : hoveredId ? 'pointer' : 'crosshair' }}
        onClick={handleCanvasClick}
        onMouseMove={handleCanvasMouseMove}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
        data-testid="svg-canvas-preview"
      >
        <div
          className="absolute"
          style={{
            transform: `translate(${pan.x}px, ${pan.y}px) scale(${scale})`,
            transformOrigin: '0 0',
            width: width,
            height: height,
          }}
        >
          <div 
            className="bg-white shadow-lg"
            style={{ width, height }}
            dangerouslySetInnerHTML={{ __html: svgContent }}
          />
          
          <svg 
            className="absolute inset-0 pointer-events-none"
            viewBox={viewBox ? `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}` : `0 0 ${width} ${height}`}
            style={{ width, height }}
          >
            {hoveredId && !selectedIds.has(hoveredId) && objectMap.get(hoveredId)?.bounds && (
              <rect
                x={objectMap.get(hoveredId)!.bounds!.x}
                y={objectMap.get(hoveredId)!.bounds!.y}
                width={objectMap.get(hoveredId)!.bounds!.width}
                height={objectMap.get(hoveredId)!.bounds!.height}
                fill="none"
                stroke="#0D99FF"
                strokeWidth={1 / scale}
                strokeDasharray={`${4 / scale} ${2 / scale}`}
                opacity={0.5}
              />
            )}
            
            {selectedObjects.map(obj => obj.bounds && (
              <g key={obj.id}>
                <rect
                  x={obj.bounds.x}
                  y={obj.bounds.y}
                  width={obj.bounds.width}
                  height={obj.bounds.height}
                  fill="none"
                  stroke="#0D99FF"
                  strokeWidth={2 / scale}
                />
                <rect
                  x={obj.bounds.x - 3 / scale}
                  y={obj.bounds.y - 3 / scale}
                  width={6 / scale}
                  height={6 / scale}
                  fill="#0D99FF"
                />
                <rect
                  x={obj.bounds.x + obj.bounds.width - 3 / scale}
                  y={obj.bounds.y - 3 / scale}
                  width={6 / scale}
                  height={6 / scale}
                  fill="#0D99FF"
                />
                <rect
                  x={obj.bounds.x - 3 / scale}
                  y={obj.bounds.y + obj.bounds.height - 3 / scale}
                  width={6 / scale}
                  height={6 / scale}
                  fill="#0D99FF"
                />
                <rect
                  x={obj.bounds.x + obj.bounds.width - 3 / scale}
                  y={obj.bounds.y + obj.bounds.height - 3 / scale}
                  width={6 / scale}
                  height={6 / scale}
                  fill="#0D99FF"
                />
              </g>
            ))}
            
            {isMarqueeSelecting && marqueeStart && marqueeEnd && (
              <rect
                x={Math.min(marqueeStart.x, marqueeEnd.x)}
                y={Math.min(marqueeStart.y, marqueeEnd.y)}
                width={Math.abs(marqueeEnd.x - marqueeStart.x)}
                height={Math.abs(marqueeEnd.y - marqueeStart.y)}
                fill="rgba(13, 153, 255, 0.1)"
                stroke="#0D99FF"
                strokeWidth={1 / scale}
                strokeDasharray={`${4 / scale} ${2 / scale}`}
              />
            )}
          </svg>
          
          {hoveredId && (
            <div 
              className="absolute px-2 py-1 bg-black/80 text-white text-xs rounded pointer-events-none whitespace-nowrap"
              style={{
                left: (objectMap.get(hoveredId)?.bounds?.x || 0) + (objectMap.get(hoveredId)?.bounds?.width || 0) / 2,
                top: (objectMap.get(hoveredId)?.bounds?.y || 0) - 24 / scale,
                transform: `scale(${1 / scale})`,
                transformOrigin: 'bottom center',
              }}
            >
              {getDisplayName(objectMap.get(hoveredId)!)}
            </div>
          )}
        </div>
        
        {allObjects.length > 0 && (
          <div className="absolute bottom-2 left-2 px-2 py-1 bg-black/60 text-white text-[10px] rounded">
            Click to select • Drag to marquee • Shift+click to add • Alt+drag to pan • Ctrl+scroll to zoom
          </div>
        )}
      </div>
    </div>
  );
}
