import type { InsertGameObject } from "@shared/schema";

interface SVGGradient {
  id: string;
  type: 'linear' | 'radial';
  stops: Array<{ offset: string; color: string }>;
  x1?: string;
  y1?: string;
  x2?: string;
  y2?: string;
  cx?: string;
  cy?: string;
  r?: string;
}

interface AnimateIdInfo {
  isAnimateFormat: boolean;
  symbolPath: string[];
  instanceName: string;
  parentSymbol?: string;
  layerInfo?: string;
  memberIndex?: number;
  fillOrStroke?: 'FILL' | 'STROKE';
  cleanDisplayName: string;
}

interface SVGObject {
  id: string;
  rawId: string;
  name: string;
  displayName: string;
  nameSource: string;
  isAutoGenerated: boolean;
  type: 'group' | 'path' | 'rect' | 'circle' | 'ellipse' | 'polygon' | 'text' | 'use';
  bounds?: { x: number; y: number; width: number; height: number };
  fill?: string;
  gradientId?: string;
  transform?: string;
  pathData?: string;
  children?: SVGObject[];
  originalMarkup?: string;
  parentId?: string;
  parentName?: string;
  parentType?: string;
  className?: string;
  dataName?: string;
  ariaLabel?: string;
  instanceOf?: string;
  symbolId?: string;
  isSymbolInstance?: boolean;
  animateInfo?: AnimateIdInfo;
  symbolPath?: string[];
}

export interface ParsedTransform {
  translateX: number;
  translateY: number;
  rotation: number;
  scaleX: number;
  scaleY: number;
  skewX: number;
  skewY: number;
}

export function parseTransformString(transform: string | undefined): ParsedTransform {
  const result: ParsedTransform = {
    translateX: 0,
    translateY: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    skewX: 0,
    skewY: 0,
  };

  if (!transform) return result;

  const matrixMatch = transform.match(/matrix\(([^)]+)\)/);
  if (matrixMatch) {
    const values = matrixMatch[1].split(/[\s,]+/).map(parseFloat);
    if (values.length >= 6) {
      const [a, b, c, d, e, f] = values;
      result.translateX = e;
      result.translateY = f;
      result.scaleX = Math.sqrt(a * a + b * b);
      result.scaleY = Math.sqrt(c * c + d * d);
      result.rotation = Math.atan2(b, a) * (180 / Math.PI);
      if (a * d - b * c < 0) {
        result.scaleX = -result.scaleX;
      }
    }
    return result;
  }

  const translateMatch = transform.match(/translate\(([^)]+)\)/);
  if (translateMatch) {
    const values = translateMatch[1].split(/[\s,]+/).map(parseFloat);
    result.translateX = values[0] || 0;
    result.translateY = values[1] || 0;
  }

  const rotateMatch = transform.match(/rotate\(([^)]+)\)/);
  if (rotateMatch) {
    const values = rotateMatch[1].split(/[\s,]+/).map(parseFloat);
    result.rotation = values[0] || 0;
  }

  const scaleMatch = transform.match(/scale\(([^)]+)\)/);
  if (scaleMatch) {
    const values = scaleMatch[1].split(/[\s,]+/).map(parseFloat);
    result.scaleX = values[0] || 1;
    result.scaleY = values[1] !== undefined ? values[1] : result.scaleX;
  }

  const skewXMatch = transform.match(/skewX\(([^)]+)\)/);
  if (skewXMatch) {
    result.skewX = parseFloat(skewXMatch[1]) || 0;
  }

  const skewYMatch = transform.match(/skewY\(([^)]+)\)/);
  if (skewYMatch) {
    result.skewY = parseFloat(skewYMatch[1]) || 0;
  }

  return result;
}

function mapSVGTypeToGameObjectType(svgType: SVGObject['type']): string {
  switch (svgType) {
    case 'group':
      return 'group';
    case 'text':
      return 'text';
    case 'rect':
    case 'circle':
    case 'ellipse':
    case 'polygon':
    case 'path':
      return 'shape';
    case 'use':
      return 'frame';
    default:
      return 'shape';
  }
}

function flattenSVGObjects(objects: SVGObject[], depth: number = 0): Array<{ obj: SVGObject; depth: number; index: number }> {
  const result: Array<{ obj: SVGObject; depth: number; index: number }> = [];
  let globalIndex = 0;

  function traverse(items: SVGObject[], currentDepth: number) {
    for (const obj of items) {
      result.push({ obj, depth: currentDepth, index: globalIndex++ });
      if (obj.children && obj.children.length > 0) {
        traverse(obj.children, currentDepth + 1);
      }
    }
  }

  traverse(objects, depth);
  return result;
}

export interface GameObjectMetadata {
  gradientId?: string;
  gradientDef?: SVGGradient;
  fill?: string;
  stroke?: string;
  pathData?: string;
  originalMarkup?: string;
  symbolPath?: string[];
}

export interface ConvertedGameObject extends Omit<InsertGameObject, 'screenId'> {
  svgId: string;
}

export function convertSVGObjectsToGameObjects(
  objects: SVGObject[],
  gradients: SVGGradient[]
): ConvertedGameObject[] {
  const flatObjects = flattenSVGObjects(objects);
  const gradientMap = new Map(gradients.map(g => [g.id, g]));
  
  return flatObjects.map(({ obj, depth, index }) => {
    const transform = parseTransformString(obj.transform);
    
    const bounds = obj.bounds || { x: 0, y: 0, width: 100, height: 100 };
    
    const x = bounds.x + transform.translateX;
    const y = bounds.y + transform.translateY;
    
    const classes: string[] = [];
    
    if (obj.className) {
      classes.push(...obj.className.split(/\s+/).filter(Boolean));
    }
    
    if (obj.animateInfo?.isAnimateFormat && obj.symbolPath) {
      obj.symbolPath.forEach(symbol => {
        const cleanSymbol = symbol.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
        classes.push(`symbol-${cleanSymbol}`);
      });
    }
    
    if (obj.isSymbolInstance && obj.instanceOf) {
      const cleanInstance = obj.instanceOf.replace(/[^a-zA-Z0-9_-]/g, '_').toLowerCase();
      classes.push(`instance-of-${cleanInstance}`);
    }
    
    const tags: string[] = [];
    
    tags.push(`svg-type-${obj.type}`);
    
    if (obj.animateInfo?.isAnimateFormat) {
      tags.push('adobe-animate');
      if (obj.animateInfo.fillOrStroke) {
        tags.push(obj.animateInfo.fillOrStroke.toLowerCase());
      }
    }
    
    if (obj.gradientId) {
      tags.push('has-gradient');
      const gradient = gradientMap.get(obj.gradientId);
      if (gradient) {
        tags.push(`gradient-${gradient.type}`);
      }
    }
    
    if (obj.parentId) {
      tags.push('has-parent');
    }
    
    if (obj.children && obj.children.length > 0) {
      tags.push('has-children');
    }
    
    const zIndex = (depth * 1000) + index;
    
    let customId: string | undefined;
    if (obj.rawId && !obj.isAutoGenerated) {
      customId = obj.rawId;
    } else if (obj.dataName) {
      customId = obj.dataName;
    }
    
    const metadata: GameObjectMetadata = {};
    
    if (obj.gradientId) {
      metadata.gradientId = obj.gradientId;
      const gradient = gradientMap.get(obj.gradientId);
      if (gradient) {
        metadata.gradientDef = gradient;
      }
    }
    
    if (obj.fill) {
      metadata.fill = obj.fill;
    }
    
    if (obj.pathData) {
      metadata.pathData = obj.pathData;
    }
    
    if (obj.symbolPath) {
      metadata.symbolPath = obj.symbolPath;
    }
    
    if (obj.originalMarkup) {
      metadata.originalMarkup = obj.originalMarkup;
    }
    
    const result: ConvertedGameObject = {
      svgId: obj.id,
      name: obj.displayName || obj.name,
      type: mapSVGTypeToGameObjectType(obj.type),
      x,
      y,
      width: bounds.width,
      height: bounds.height,
      rotation: transform.rotation,
      scaleX: transform.scaleX,
      scaleY: transform.scaleY,
      opacity: 1,
      visible: true,
      customId: customId || null,
      classes,
      tags,
      zIndex,
      dataKey: null,
      mediaUrl: null,
      audioUrl: null,
      figmaNodeId: null,
      metadata: Object.keys(metadata).length > 0 ? metadata : null,
    };
    
    return result;
  });
}

export interface SVGImportResult {
  objects: ConvertedGameObject[];
  gradients: SVGGradient[];
  summary: {
    totalObjects: number;
    byType: Record<string, number>;
    hasGradients: boolean;
    isAdobeAnimate: boolean;
  };
}

export function prepareSVGImport(
  objects: SVGObject[],
  gradients: SVGGradient[]
): SVGImportResult {
  const convertedObjects = convertSVGObjectsToGameObjects(objects, gradients);
  
  const byType: Record<string, number> = {};
  let isAdobeAnimate = false;
  
  for (const obj of convertedObjects) {
    byType[obj.type] = (byType[obj.type] || 0) + 1;
    if (obj.tags?.includes('adobe-animate')) {
      isAdobeAnimate = true;
    }
  }
  
  return {
    objects: convertedObjects,
    gradients,
    summary: {
      totalObjects: convertedObjects.length,
      byType,
      hasGradients: gradients.length > 0,
      isAdobeAnimate,
    },
  };
}

export type { SVGObject, SVGGradient };
